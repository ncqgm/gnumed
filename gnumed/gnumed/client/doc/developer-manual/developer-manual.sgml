<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<book>
   <bookinfo>
     <date>2002-09-03</date>
     <title>GNUMed</title>
     <subtitle>Developers's Manual</subtitle>
    
	<author>	
      		<firstname>Gerardo</firstname>
		<surname>Arnaez</surname>
      	</author>

     	<author>	
      		<firstname>Hilmar</firstname>
		<surname>Berger</surname>
    	</author>


<abstract>
	<para>      
      Copyright (c) 2001,2002 GNUMed developers</para>
      <para>
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, with no
      Front-Cover Texts, and with no Back-Cover Texts.</para>
      <para>
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</para>
   </abstract>

<revhistory>
      <revision>
	<revnumber>0.1.2</revnumber>
	<date>2002-09-09</date>
	<authorinitials>hb</authorinitials>
	<revremark>Further inclusion of gnumed whitepapers.</revremark>
      </revision>

      <revision>
	<revnumber>0.1.1</revnumber>
	<date>2002-08-12</date>
	<authorinitials>hb</authorinitials>
	<revremark>Added some basic description of gnumed client modules.</revremark>
      </revision>


      <revision>
	<revnumber>0.1</revnumber>
	<date>2002-08-03</date>
	<authorinitials>gea</authorinitials>
	<revremark>Initial developers manual written, mostly will copy from savanah.gnu.org</revremark>
      </revision>


    </revhistory>


   </bookinfo>
   <toc></toc>

<preface>
	<title>Preface</title>
	<para>GnuMed never sleeps.</para>
</preface>

<chapter id="intro">
     <title>Introduction</title>

    <para>GNUMed is  a comprehensive scalable software solution for paperless 
medical practice with emphasis on privacy protection, secure patient-centric 
record sharing, decision support and ease of use.
</para>
       <para>GNUMed is not yet ready for download as a package.
It will become available at 
<ulink url="http://gnumed.org/">
<citetitle>gnumed.org</citetitle></ulink>.
 
It is released under the GNU 
General Public Licence, see the file <filename>LICENCE</filename> for details.
</para>

  </chapter>

  <chapter>
    <title>Checking out, Checking in GnuMed CVS</title>
    <sect1>
      <title>Developer CVS Access via SSH (Version 1, RSA)</title>
      <para>Only project developers can access the CVS tree via this method. SSH1 must be installed on your client machine. If you have SSH version two, add
	<screen>Host subversions.gnu.org
Protocol 1</screen>
      </para>
      <para>In my case, I simply re-installed ssh, and made sure both Protcol 1 and 2 were allowed and then put in <screen>Protocol 1,2</screen> in my <emphasis>~/.ssh/config</emphasis> file.
      </para>

      <para>Getting a ssh1 key is quite simple. You may either use an already existing ssh1-key (e.g. the one you already use to encrypt/sign your mail) or create a new one. </para>

      <sect2>
      	<title> Use an existing ssh1-key </title>
      	<para>
      	Copy the contents of the public part of the key (usually the file ~/.ssh/identity.pub to the ssh-key text field at Savannah (see below).
      	Add the line <screen>export CVS_RSH=ssh</screen> to your .profile.
      	</para>
      </sect2>
      <sect2>
      	<title> Create a new ssh1-key (using OpenSSH) </title>
      	<procedure>
	    <step>
	    	<para>
      	    	<screen> ssh-keygen [-i ~/.ssh/key_file_name] -t rsa1  </screen>
      	    	key_file_name is the name of the key you want to create. If you want to create your primary key (the key you want to use for mail etc.) you can drop the part in brackets. In this case you will find the key file in ~/.ssh/identity.pub.
      	    	</para>
	    </step>
	    <step>
      	    	<para>
      	    	Then copy and paste the contents of the public part of the key (the file ~/.ssh/key_file_name.pub to the ssh-key text field at Savannah (see below). Be sure not to copy line breaks.
		</para>
	    </step>
	    <step>
      	    	<para>
      	    	If you created a your primary key,add the line <screen>export CVS_RSH=ssh</screen> to your .profile.
      	    	</para>
		<para>
		If you created a new key particularly for the cvs, enter the following lines
		<screen> echo "#! /bin/sh\nssh -i ~/.ssh/key_file_name $@" > ~/bin/ssh_cvs
chmod +x ~/bin/ssh_cvs
    	    	</screen>
    	    	Add the line <screen>export CVS_RSH=ssh_cvs</screen> to your .profile.		
    	    	</para>
	    </step>
	</procedure>
	</sect2>
	<sect2>
	    <title> Uploading your SSH1-Key </title>
	    <para> Copy and paste the public part of the ssh1-key to savannah.gnu.org using https://savannah.gnu.org/account/editsshkeys.php.
	    </para>
	</sect2>
    </sect1>
    <sect1>
      <title>Basic commands</title>
      <para>Again just making it clear</para>
      <para>To Checkout CVS as a developer, you will type:</para>
      <screen>cvs -z3 -d<emphasis>dude</emphasis>@subversions.gnu.org:/cvsroot/gnumed/ co gnumed</screen>

      <para>To update your tree, you will type:
      <screen>cvs -z3 -ddude@subversions.gnu.org:/cvsroot/gnumed/ update -d [-P] gnumed
      </screen>
      You might want to use the -P option, which removes empty directories from your copy of the CVS.	
      </para>
      <para>To commit your changes, type:</para>
      <screen>cvs -z3 -ddude@subversions.gnu.org:/cvsroot/gnumed/ commit gnumed</screen>
      <para>Remember that you will be asked for your passphrase. This is different from your password to savannah.gnu.org</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Coding Guidelines</title>
    <sect1>
      <title>strings and translation</title>
      <para>hardcoded error strings meant for developers / debugging are in English.All other strings MUST be translateable, that is called as a gettext 
function. To achieve this, you do the following:
      </para>
      <para>If your modules can be called as a standalone script you
should add this to your main part:
	<screen>
if name == '__main__':
	import gettext
	_ = gettext.gettext()
    # ... now on to other stuff
	</screen>
If your module is invoked from within the GNUmed framework the
translation function _() is automatically defined for you.
      </para>
      <para>
Now, whenever you use a string, do it like
	<screen>
print _("this will be automatically translated")
instead of
 print "this can't be translated and should thus not be written this way"
	</screen>
      </para>
    </sect1>

    <sect1>
      <title>Database Guidelines</title>
      <para>When doing database work, NEVER rely on a table being present in the "default" database. Lookup the appropriate service 
(as listed in http://gnumed.net/whitepapers/serviceslist.html) and use it 
accordingly - for example ALL person and address related details are 
available via the service "personalia" now.</para>
      <para>
Whether "personalia" is actually implemented in "default" or on some other 
server in a completely different database should not matter to client 
programmers. Just request the right service from the database broker 
object, and that's it - should work.</para>
      <para>
In order to make this testable, you must set up your configuration tables 
in the default database accordingly
(database name in "db", service in "distributed_db", reference to db and 
distributed_db in "config" attributes "db" and "ddb")
      </para>
    </sect1>

    <sect1>
      <title>Widgets</title>
      <para>When trying to map database results to widgets, remember that not all 
widgets can use the same functions (like SetValue()) under all 
circumstances to set their properties. Notable examples for exceptions are 
"choice boxes" and "combo boxes". It might be preferrable to have a 
function SetData(), UpdateData(), ClearData() for each dialog instead - 
far more control over what is actually happening to the widgets, though 
unfortunately a little bit more typing.</para>

    </sect1>

    <sect1>
      <title>Comments. Documenting Code</title>
      <sect2>
	<title>Module documention</title>
      	    <para>Always insert some lines of description of the module, containing at least the author and one line of short explanation. Remember that a lot of people might have to read and understand your code. Document as much as possible. Add example code how to use the module where possible and necessary. 
Please insert the following template at the beginning of the file:</para>
    	    	<screen>
#############################################################################
# ModuleName - one line explanation             
# verbose documentation, example code
# @author: author name                                                       
# @copyright: author                                                            
# @license: GPL (details at http://www.gnu.org)                                 
# @dependencies: any libs / program versions the module might depend on       
# @change log:                                                                  
#       date initials of the author changes made                
#                                                                               
# @TODO:        
#############################################################################
    	</screen>
      </sect2>

      <sect2>
	<title>Docstring documention</title>
      <para>try to always insert at least one line of docstring 
unless the function is no more than a couple of lines long and perfectly 
self-explanatory</para>
      </sect2>

      <sect2>
	<title>COMMENTS</title>
	<para>mark places that need fixing with a comment like this:
	  <screen>
# FIXME: a comment on what should be fixed how
... your code ...</screen>
	</para>
      </sect2>
    </sect1>

    <sect1>
      <title>CVS Guidelines</title>
      <para>Always test before you check in (yes, I have been guilty of not
  heeding my own advice, sorry)</para>
    </sect1>

    <sect1>
      <title>DEBUGGING/LOGGING</title>
      <para>Place markers before/after logging statements
  that can be commented out once things work like this:
	<screen>
#&lt;DEBUG&gt;
gmLog.Log(gmLog.lData, "this is a completely useless and wasteful, excessive log message")
#&lt;/DEBUG&gt;</screen>
    </chapter>

    <chapter>
    	<title> Modules </title>
<sect1><title>python-common</title>
<sect2><title>gmCLI.py</title><screen>

GNUmed command line options handling.

All command line argument handling should go through this module.

Theory of operation:
Upon startup the command line is parsed for any option
arguments. Those are assumed to start with at least one "-".
Any arguments not starting with a "-" are considered
non-option arguments. Option arguments are then stored in
the module level global dictionary _cli_args{}.

Your module should import gmCLI and query for existence of
one-letter arguments like this:

if gmGLI.has_arg("-v"):
	do_something_verbosely()
else:
	be_rather_quiet()

If you want to access the value for a long option you should
first check for it's existence and then access the value:

if gmCLI.has_arg("--foo"):
	print gmCLI.arg["--foo"]
else:
	print "no argument --foo specified"

Remember that even though a long argument exists it may not
have a value, e.g. the value might amount to an empty string.

Limitations:
1) Aggregated short arguments are not supported, eg you CANNOT say
    my-script -fo
   instead of
    my-script -f -o
   In fact, "-fo" will be truncated to "-f"
2) Values on short arguments are not supported. Use long
   style arguments for that, e.g.:
    my-script --foo=bar

</screen></sect2>
<sect2><title>gmCachedAddress.py</title><screen>

 gmCachedAddress - data broker for a person's address
 @TODO: Almost everything

 class AddressCache(gmDBCache.DBcache)
 class CachedAddress(gmDBCache.CachedDBObject)
	def get(self, id=None, by_reference=0, refresh_only=0):
	def create_address_link( self, addressMap, db):
	def update_address_link(self, addressMap, db):
	def dictresult(self, id=None):
</screen></sect2>
<sect2><title>gmConf.py</title><screen>
Configuration model
This duplicates some of Karsten's work, but a configuration tool is required
that talks to the remote database

def GetAllConfigs ():
def SetConfig (key, value):
# HACK FOR NOW
config = {'main.use_notebook':1, 'main.shadow':1, 'main.shadow.colour':(131, 129, 131), 'main.shadow.width':10}

</screen></sect2>
<sect2><title>gmConf.py</title>
<screen>
# gmCachedDBObject : abstraction and performance improvement for simple
#                     database query result objects
#
#
# CachedDBObject is a base class which should not
# be used directly.
# In order to derive a functional class from CachedDBObject, do as follows:
#
# class Derived(CachedDBObject):
#
#       #first, create the "shared buffer" variable
#	dbcache = DBcache()
#       #this static variable MUST have the name "dbcache"
#       #it must create an instance of DBcache or a subclass thereof
#
#       #then, create the appropriate constructor
#	def __init__(...)
#		#now create a reference to the static variable
#		self.cache = Derived.dbcache
#		#and pass it to the constructor
#		cachedDBObject.__init__( cache=self.cache...)
#               #__init__ MUST call the base class constructor
#
# When creating more than one instance from "Derived",
# the callback system should be used to ensure that any
# instance using the shared buffer gets notified of buffer changes:
#
# myInstance = Derived(...)
# myInstance.notify_me('identifier of myInstance', callback_function)
#
# where 'identifier of myInstance' is an arbitrary string and
# 'callback function' is a function of the prototype:
#
# function('identifier of callback triggering class', 'id')
#
# where 'id' typically would be the foreign key causing the
# current data set in the buffer
#

class DBcache:
	"prototype for a database object cache 'static' (singleton) information"

class CachedDBObject

	def reset(self)
		"force a re-query of buffer on next data access attempt"

	def setQueryStr(self, querystr)

	def getQueryStr(self)

	def setId(self, id, lazy=0)

	def getId(self)
		"get the ID of the current object"

	def get(self, id=None, by_reference=0, refresh_only=0):
		returns the buffer. If id is not None and not in cache,
		the backend will be queried.
		If by_reference is not zero, a copy of the buffer instead 
		of a reference to it will be returned.
		When using multiple threads to access the data,
		always use copies of the buffer!

	def notify_me(self, who, callback=None):
    		Register function 'callback' for caller 'who'

		If callback is None, the callback for caller 'who'
		will be removed (if exists)
		'callback' is a function that accepts two parameters:
		The first parameter is the identity of the registered
		caller ('who'), the second parameter is the buffer id.
		'callback' must not return anything

	def queue_notification(self, queue=1):
		simple helper mechanism to ensure only the most recent thread
		updates widgets on data change
		
	def notify(self):
		forces execution of all registered callback functions
		This function will be called whenever the buffer changes
		
	def attributes(self):
		returns row attributes ('field names')

	def pprint(self):
		"format buffer content in printable form"

	def dictresult(self):

</screen>
</sect2>
<sect2 id=gmDispatcher><title>gmDispatcher.py</title><screen>

     Provides global signal dispatching services.

class DispatcherError(exceptions.Exception)

class _Any:
    	# Helper class
	
Methods provided by gmDispatcher:

     def connect(receiver, signal=Any, sender=Any, weak=1)
	Connect receiver to sender for signal

	If sender is Any, receiver will receive signal from any sender.
	If signal is Any, receiver will receive any signal from sender.
	If sender is None, receiver will receive signal from anonymous.
	If signal is Any and sender is None, receiver will receive any 
	    signal from anonymous.
	If signal is Any and sender is Any, receiver will receive any 
	    signal from any sender.
	If weak is true, weak references will be used.

     def disconnect(receiver, signal=Any, sender=Any, weak=1)
	Disconnect receiver from sender for signal.

	Disconnecting is not required. The use of disconnect is the same as for
	connect, only in reverse. Think of it as undoing a previous connection.

     def disconnect(receiver, signal=Any, sender=Any, weak=1)
	Disconnect receiver from sender for signal.

	Disconnecting is not required. The use of disconnect is the same as for
	connect, only in reverse. Think of it as undoing a previous connection.

     def send(signal, sender=None, **kwds)
	Send signal from sender to all connected receivers.

	Return a list of tuple pairs [(receiver, response), ... ].
	If sender is None, signal is sent anonymously.

     def _call(receiver, **kwds)
	Call receiver with only arguments it can accept.

     def safeRef(object)
	Return a *safe* weak reference to a callable object.

class BoundMethodWeakref

    def __init__(self, boundMethod):
        Return a weak-reference-like instance for a bound method.

    def __repr__(self)
        Return the closest representation.

    def __call__(self)
        Return a strong reference to the bound method.

    def _removeReceiver(receiver)
    	Remove receiver from connections.

    def _cleanupConnections(senderkey, signal)
        Delete any empty signals for senderkey. Delete senderkey if empty.

    def _removeSender(senderkey)
    	Remove senderkey from connections.

</screen></sect2>
<sect2><title>gmExceptions.py</title><screen>
class ConnectionError(Exception)
	#raised whenever the database backend connection fails

class ConfigError(Exception)
	#raised whenever a configuration error occurs

class NoGuiError(Exception):
	#raised whenever the database backend connection fails

class PureVirtualFunction(Exception):
	#raised whenever the database

</screen></sect2>
<sect2><title>gmGuiBroker.py</title><screen>
GNUMed GUI element brokerage

This module provides wrappers for the equivalent of global
variables needed for a gnumed GUI client interface

class GuiBroker:
	Wrapper for global objects needed by GNUMmed GUI clients

	#This class wraps all global gui objects (variables)for a gnumed
	#application. The static (at application level)dictionary
	#__objects can be accessed through the method addobject
	#and getobject.
	#So, if you need to access the main window frame, you would
	#query an instance of GuiBroker for it.

	def addobject(self, widget, key=None):
		Add an object to the gnumed gui object dictionary"

		An object can be anything (class, variable, widget)
		The "key" is a key expression (number, text) that
		allows you to retrieve the object.
		Convention for keys is the widget or variable name
		as a text string
		If key is not passed as parameter, a unique serial
		number is allocated as key and returned

	def getobject(self, key):
		allows to retrieve a gnumed gui element; see addobject()
		regarding the key parameter

	def keylist(self):
		returns a list of all keys; see documentation for the
		dictionary data type

	def valuelist(self):
		returns a list of all values; see documentation for the
		dictionary data type

	def itemlist(self):
		returns a list of all key:value pairs;
		see documentation for the dictionary data type

	def __getitem__(self, key):
		Allows retrieving the value via value = instance[key]

	def __setitem__(self, key, object):
		Allows access in the style of instance[key]=value

</screen></sect2>
<sect2><title>gmI18N.py</title><screen>
GNUmed client internationalization/localization.

All i18n/l10n issues should be handled through this modules.

Theory of operation:

By importing this module a textdomain providing translations is
automatically installed. The translating method gettext.gettext()
is installed into the global (!) namespace as _(). Your own modules thus
need not do _anything_ (not even import gmI18N) to have _() available
to them for translating strings. You need to make sure, however, that
gmI18N is imported in your main module before any of the modules using
it. In order to resolve circular references involving modules that
absolutely _have_ to be imported before this module you can explicitely
import gmI18N into them at the very beginning.

The text domain (i.e. the name of the message catalog file) is derived
from the name of the main executing script unless explicitely given on
the command line like this:
 --text-domain=&lt your text domain &gt

This module searches for message catalog files in 3 main locations:
 - in standard POSIX places (/usr/share/locale/ ...)
 - below $GNUMED_DIR/locale/
 - below (one level above binary directory)/locale/

For DOS/Windows I don't know of standard places so only the last
option will work unless you have CygWin installed. I don't know a
thing about classic Mac behaviour. New Mac's are POSIX, of course.

The language you want to see is derived from the following locale
related environment variables (in this order):
 - LANGUAGE
 - LC_ALL
 - LC_MESSAGES
 - LANG

</screen></sect2>
<sect2><title>gmLog.py</title><screen>

GNUMed client log handling.

All error logging, user notification and otherwise unhandled 
exception handling should go through classes or functions of 
this module

Theory of operation:

A logger object is a unifying wrapper for an arbitrary number
of log targets. A log target may be a file, syslog, the console,
or an email address, or, in fact, any object derived from the
class cLogTarget. Log targets will only log messages with at least
their own message priority level (log level). Each log target
may have it's own log level.

There's also a dummy log target that just drops messages to the floor.

By importing gmLog into your code you'll immediately have
access to a default logger: gmDefLog. Initially, the logger has
a log file as it's default target. The name of the file is
automatically derived from the name of the main application.
The log file will be found in one of the following standard
locations:

1) given on the command line as "--log-file=&lt log file &gt"
2) ~/.&lt base_name &gt/&lt base_name &gt .log
3) /var/log/&lt base_name &gt/&lt base_name &gt .log
4) /var/log/&lt base_name &gt .log
5) /dir/of/binary/&lt base_name &gt .log	- mainly for DOS/Windows

where &lt base_name &gt is derived from the name
of the main application.

By importing gmLog and logging to the default log your modules
never need to worry about the real message destination or whether
at any given time there's a valid logger available. Your MAIN
module simply adds real log targets to the default logger and
all other modules will merrily and automagically start logging
there.

You can of course instantiate any number of additional loggers
that log to different targets alltogether if you want to keep
some messages separate from others.

Usage:
1.) if desired create an instance of cLogger
2.) create appropriate log targets and add them to the default logger or your 
    own (from step 1)
3.) call the cLogger.LogXXX() functions

# log levels:
# lPanic - try to log this before we die
# lErr   - some error occured, may be recoverable
# lWarn  - something should be done about this though it's not fatal
# lInfo  - user info like program flow
# lData  - raw data processed by program

# injudicious use of lData may lead to copious amounts of log output
# and has inherent security risks (may dump raw data including passwords,
# sensitive records, etc)


class cLogger:
	def __init__(self, aTarget=None):
		Open an instance of cLogger and initialize a target.
		in case there's no target given open a dummy target

	def close(self):
		Close this logger and cleanly shutdown any open targets.

	def AddTarget (self, aTarget):
		Add another log target.

		- targets must be objects derived from cLogTarget
		- ignores identical targets
		- the number of concurrent targets is potentially unlimited

	def RemoveTarget (self, anID):
		Remove a log target by it's ID.
		- clients have to track target ID's themselves if they want to
		  remove targets

	def Log(self, aLogLevel, aMsg, aRawnessFlag = lUncooked):
		Log a message.

		- for a list of log levels see top of file
		- messages above the currently active level of logging/verbosity
		  are dropped silently
		- if Rawness == lCooked non-printables < 32 (space) will be mapped to
		  their name in ASCII
		- FIXME: this should be a Unicode mapping

	def LogDelimiter (self):
		Write a horizontal delimiter to the log target.

	def LogException(self, aMsg, exception, fatal=1):
		Log an exception.
		'exception' is a tuple as returned by sys.exc_info()

	def SetAllLogLevels (self, aLogLevel = None):
		Set a certain log level on all targets.

private classes / methods:
class cLogTarget:
	Base class for actual log target implementations.
	- derive your targets from this class
	- offers lots of generic functionality

	def __init__(self, aLogLevel = lErr)
	def close(self)
	def getID (self)
	def SetLogLevel(self, aLogLevel)
	def writeMsg (self, aLogLevel, aMsg)
	def hasLogged (self)
	def writeDelimiter (self)
	def flush (self)

</screen></sect2>
<sect2><title>gmLoginInfo.py</title><screen>
# gmLoginInfo - a class to encapsulate Postgres login information

class LoginInfo:
	"a class to encapsulate Postgres login information"

	def __init__(self, user, passwd, host='localhost', port=5432, database='gnumed', options='', tty='', profile='default'):

	def SetInfo(self, user, passwd, host='localhost', port=5432, dbname='gnumed', opt='', tty='', profile='default'):

	def GetInfo(self):

	def GetInfoStr(self):
	    # doesn't hand out passwords 

	def GetPGDB_DSN(self):
    	    return dsn in colon delimited form as one string and host
	    
	def GetDBAPI_DSN(self):
    	    return dsn in colon delimited form as one string
	  
    	def SetUser(self, user):
	def GetUser(self):
	def SetPassword(self, passwd):
	def SetPassword(self, passwd):
	def GetPasswordHash(self):
	def SetDatabase(self, dbname):
	def GetDatabase(self):
	def SetHost(self, host):
	def SetHost(self, host):
	def SetPort(self, port):
	def GetPort(self):
	def SetOptions(self, opt):
	def GetOptions(self):
	def SetTTY(self, tty):
	def GetTTY(self):
	def GetTTY(self):
	def GetTTY(self):

	def Clear(self):
		"clears all connection information regarding user, password etc."

</screen></sect2>
<sect2 id=gmPG><title>gmPG.py</title><screen>
# gmConnectionPool - Broker for Postgres distributed backend connections

as of 09.08.2002 tries to handle psycopg (Zope), PyPGSql and pgdb

class ConnectionPool:
	"maintains a static dictionary of available database connections

	def __init__(self, login=None):
		parameter login is of type gmLoginInfo.LoginInfo

	def GetConnection(self, service):
		"if a distributed service exists, return it - otherwise return the default server"

	def ReleaseConnection(self, service):
		"decrease reference counter of active connection"

	def GetAvailableServices(self):
		list all distributed services available on this system
		(according to configuration database)

	def Connected(self):

	def LogError(self, msg):
		"This function must be overridden by GUI applications"

#---------------------------------------------------
# database helper functions
#---------------------------------------------------
def cursorIndex(cursor):
	returns a dictionary of row atribute names and their row indices

def descriptionIndex(cursordescription):
	returns a dictionary of row atribute names and their row indices

def dictResult(cursor, fetched=None):
	"returns the all rows fetchable by the cursor as dictionary (attribute:value)"

def fieldNames(cursor):
	"returns the attribute names of the fetched rows in natural sequence as a list"
	
def listDatabases(service='default'):
	"list all accessible databases on the database backend of the specified service"

def listUserTables(service='default'):
	"list the tables except all system tables of the specified service"

def listSystemTables(service='default'):
	"list the system tables of the specified service"

def listSystemTables(service='default'):
	"list the system tables of the specified service"

def quickROQuery(query, service='default'):
	a quick read-only query that fetches all possible results at once
	returns the tuple containing the fetched rows and the cursor 'description' object

def getBackendName():

def prompted_input(prompt, default=None):

def inputTMLoginParams():
	text mode input request of database login parameters

def inputWXLoginParams():
	GUI (wx) mode input request of database login parameters.
	Returns gmLoginInfo.LoginInfo object

def inputLoginParams():
	"input request for database backend login parameters. Try GUI dialog if available"

</screen></sect2>
<sect2><title>gmPlugin.py</title><screen>

# gmPlugin - base classes for GNUMed's plugin architecture
class gmPlugin:
	base class for all gnumed plugins

	def provides ():
		Returns a list of services that the plugin provides

	def requires ():
		Requires a list of services that must be registered
		before this plugin is registered. The configuration
		tool must check these and make sure the load order
		satisfies the plugins' requirements

	def description ():
		Returns a brief description of the plugin.

	def name (self):

	def register(self):

	def unregister(self):

class wxBasePlugin (gmPlugin):
	
	
	base class for all plugins providing wxPython widgets.
	Plugins must have a class descending of this class in their file, which MUST HAVE THE SAME NAME AS THE FILE.
	The file must be in a directory which is loaded by LoadPluginSet (gui/ for the moment, others may be added for different plugin types)

	# NOTE: I anticipate that all plugins will in fact be derived
	# from this class. Without the brokers a plugin is useless (IH)

	def __init__(self, guibroker=None, callbackbroker=None, dbbroker=None, params=None):

	def GetIcon (self):
		Return icon representing page on the toolbar.
		This is the default behaviour. GetIconData should return
		pickled, compressed and escaped string with the icon data.

		If you want to change the behaviour (because you want to load
		plugin icons from overseas via a satellite link or something
		you need to override this function in your plugin (class).

		Using this standard code also allows us to only import cPickle
		and zlib here and not in each and every plugin module which
		should speed up plugin load time :-)

		# FIXME: load from config which plugin we want
		# which_icon is a cookie stored on the backend by a config manager,
		# it tells the plugin which icon to return data for,

	def GetIconData(self, anIconID = None):
		# FIXME: in overriding methods need to be very careful about the
		# type of the icon ID since if we read it back from the database we
		# may not know what type it was

	def GetWidget (self, parent):
		Return the widget to display

	def MenuInfo (self):
		Return tuple of (menuname, menuitem).
		menuname can be "tools", "view", "help", "file"

	def Raise (self):
		Raises this plugin to the top level if not visible.

	def Shown (self):
		Called whenever this module is shown onscreen.

class wxNotebookPlugin (wxBasePlugin):
	
	Base plugin for plugins which provide a 'big page'
	Either whole screen, or notebook if it exists
		
	def register (self):
		Register ourselves with the main notebook widget.

	def unregister (self):
		Remove ourselves.

	def Raise (self):
	def OnMenu (self, event):
	def GetNotebookNumber (self):
	def DoToolbar (self, tb, widget):
		
		sets up the toolbar for this widget.
		tb is the toolbar
		widget is the widget returned by GetWidget () for connecting events


class wxPatientPlugin (wxBasePlugin):
	
	A 'small page', sits inside the patient view, with the side visible

	def register (self)
	def OnTool (self, event):
	def Raise (self):
	def unregister (self):


def LoadPlugin (aPackage, plugin_name, guibroker = None, dbbroker = None):
	Loads a plugin from a package directory.

	- "set" specifies the subdirectory in which to find the plugin
	- this knows nothing of databases, all it does is load a named plugin

	There will be a general 'gui' directory for large GUI
	components: prescritions, etc., then several others for more
	specific types: export/import filters, crypto algorithms
	guibroker, dbbroker are broker objects provided
	defaults are the default set of plugins to be loaded

	FIXME: we should inform the user about failing plugins

def GetAllPlugins (set):
	
	Searches the directory for all plugins

def UnloadPlugin (set, name):
	
	Unloads the named plugin

</screen></sect2>
<sect2><title>gmdbf.py</title><screen>

This is a module for reading dbf files.

It has been modified thanks to suggestions and patches from Jeff Bauer
and Kevin Dahlhausen. Unfortunately I lost patches which fix
endianness problems, which were sent to me by someone, so that will
have to wait. I do not use this module much these days, but since it
seems to be in use "out there" I thought I would finally make an
update available. This version should be more portable. Also, rather
than printing an error message an exception is now raised when the dbf
file appears to be corrupt.

Usage: the following

import dbf
db = dbf.dbf('mydata.dbf')

creates a dbf object db associated with an existing dbf file
'mydata.dbf'.  The dbf file is opened by the constructor. If the file
is not there IOError is raised. If the file appears not to be a dbf
format file, TypeError is raised.

If you prefer to create a dbf object, but open the actual file later,
you can use the following:

import dbf
db = dbf.dbf('mydata.dbf', openit=0)

and then you can call

db.open()

to actually open the file. Note that the constructor, if called this
way, does not verify that the file is there, so the IOError exception
is raised by the call to open.

Once the dbf object is created and opened (implicitly or not), the
following are available:

-- db.fields  : returns a a list of tuples describing the fields
-- db.nrecs   : returns the number of records
-- db[n]      : returns a tuple containing record number n (0 <= n < nrecs)
-- db.status(): prints some essential data about the dbf file

So to list the first two fields of mydata.dbf, assuming they are string
fields, one might write:

import dbf
from string import strip
db=dbf.dbf('mydata.dbf')
for k in db:
    print "%s, %s" % (strip(k[1]), strip(k[2]))


Good luck!

class dbf:
	def __init__(self, fname, openit=1):
	def open(self):
	def _get(self, recno):
	def __getitem__(self, recno):
	def dictresult(self, recno):
	def status(self):
	def close(self):


</screen>
</sect2>

<sect2 id=gmSignals><title>gmSignals.py</title>
<screen>
# gmSignals.py

gmSignals - factory functions returning GnuMed internal signal strings. 
This helps to avoid that  simple typographic mistakes result in messages
not being dispatched. It would allow to do messenging house keeping as well.

def popup_notice():
	a notice of general interest has been received

def popup_alert():
	an important notice of general ineterest has been received
	
def patient_selected():
	the current active patient displayed by the client has been selected
	
def patient_modified():
	the current patients demographic data has been modified
	
def medication_modified():
	the current patient's medication has been modified
	
def waitingroom_added():
	a patient has been added to the waiting room
	
def waitingroom_incons():
	a patient has started his consultation with the doctor
	
def waitingroom_left():
	a aptient has left the waiting room, finished his consultation

</screen>
</sect2>
</sect1>

<sect1><title>wxpython</title>
<sect2><title>gnumed.py</title><screen>
main wrapper setting up global brokers, logging, command line argument handling, i18n, etc.
GNUmed
======
This is the launcher for the main GNUmed GUI client. It is
intended to be used as a standalone program.

Command line arguments:

--quiet
 Be extra quiet and show only _real_ errors in the log.
--debug
 Be extra verbose and report nearly everything that's going
 on. Useful for, well, debugging :-)
--talkback
 Run the client and upon exiting run a talkback client where
 you can enter a comment and send the log off to the bug hunters.
 Very useful when used in conjunction with --debug.
--text-domain=<&lt a_text_domain &gt
 Set this to change the name of the language file to be loaded.
 Note, this does not change the directory the file is searched in,
 only the name of the file where messages are loaded from. The
 standard textdomain is, of course, "gnumed.mo".
--log-file=&lt a_log_file> &gt
 Use this to change the name of the log file.
 See gmLog.py to find out where the standard log file would
 end up.
--help, -h, or -?
 Well, show this help.


def get_base_dir():
	Retrieve the global base directory.

	   The most preferable approach would be to just let
	   the user specify the name of a config file on the
	   command line but for that we'd have to load some
	   non-standard modules already unless we want to
	   duplicate the entire config file infrastructure
	   right here.

	   1) regardless of OS if the environment variable GNUMED_DIR
		  is set this directory will be tried as a base dir
		  - this will allow people to start GNUmed from any dir
		    they want on any OS they happen to run
		  - the variable name has been chosen to be descriptive
		    but still not waste too many resources
	   2) assume /usr/share/gnumed/ as base dir
		  - this will work on POSIX systems and may work on
		    Cygwin systems
		  - this is the no-brainer for stock UN*X
	   3) finally try one level below path to binary
	      - last resort for lesser systems
		  - this is the no-brainer for DOS/Windows
		  - it also allows running from a local CVS copy


further action:
- import gmLog, gmCLI
- import gmI18N, gmGuiBroker, gmGuiMain
- import gmTalkback if necessary

jump to gmGuiMain.main()

</screen></sect2>
<sect2><title>gmGuiMain.py</title><screen>

GNUMed GUI client
The application framework and main window of the
all signing all dancing GNUMed reference client.

from wxPython.wx import *
from wxPython.html import *

import gmLogFrame, gmGuiBroker, gmPG, gmSQLSimpleSearch, gmSelectPerson, gmConf, gmLog, gmPlugin
import images
import images_gnuMedGP_Toolbar                 #bitmaps for use on the toolbar
import images_gnuMedGP_TabbedLists             #bitmaps for tabs on notebook
import gmGuiElement_HeadingCaptionPanel        #panel class to display top headings
import gmGuiElement_DividerCaptionPanel        #panel class to display sub-headings or divider headings 
import gmGuiElement_AlertCaptionPanel          #panel to hold flashing alert messages
import gmGP_PatientPicture                     #panel to display patients picture 
import gmGP_Toolbar                            #panel with two toolbars on top of the screen

from gmI18N import gmTimeformat

class MainFrame(wxFrame):
	GNUmed client's main windows frame
	This is where it all happens. Avoid popping up any other windows.
	Most user interaction should happen to and from widgets within this frame

	def __init__(self, parent, id, title, size=wxPyDefaultSize):
		You'll have to browse the source to understand what the constructor does

		# initialize the gui broker
		# allow access to a safe exit function for all modules in case of "emergencies"
		# setup status bar
		# allow all modules to access our status bar
    	    	
		# connect to backend

    	    	# get current user and display it

    	    	# setup platform dependent data
		# create menus
		# setup accelerators
		# register events

		# create the  the main sizer to contain all the others on the form
		# create a top vertical box sizer for the main window
	
		# create a horizontal sizer which will contain all windows at the top of the
		# screen (ie menu's and picture panel - which are on sub sizers)
		# add a wxPanel to this sizer which sits on the left and occupies 90% of width
		# followed by panel for the patients picture which occupies 10%. Add labels for
		# demo patients

		# setup the "top row", where all important patient data is always on display
		# set up the main notebook (gmNotebook)
		# relate plugins to the notebook (via gmPlugin.GetAllPlugins ('gui'))
		# position the Window on the desktop and show it


	def SetupPlatformDependent(self):
		#do the platform dependent stuff

	def OnNotebook (self, event):
		Called when notebook changes

	def RegisterEvents(self):
		#register events we want to react to

	def OnAbout(self, event):
		" A simple 'about' dialog box"

	def SetupAccelerators(self):
	def SetupStatusBar(self):
		#add time and date display to the right corner of the status bar
		#update every second

	def Notify(self):
		Displays date and local time in the second slot of the status bar"

	def CreateMenu(self):
		Create the main menu entries. Individual entries are
		farmed out to the modules

	def Lock(self):
		Lock GNUmed client against unauthorized access"

	def Unlock(self):
		Unlock the main notebook widgets
		As long as we are not logged into the database backend,
		all pages but the 'login' page of the main notebook widget
		are locked; i.e. not accessible by the user

		#unlock notebook pages
		# go straight to patient selection

	def OnFileExit(self, event):

	def CleanExit(self):
		This function should ALWAYS be called when this
		program is to be terminated.
		ANY code that should be executed before a regular shutdown
		should go in here
    
    	def OnClose(self,event):

	def OnIdle(self, event):
		Here we can process any background tasks

	def OnIconize(self, event):

	def OnMaximize(self, event):

	def OnPageChanged(self, event):

class gmApp(wxApp):
	def OnInit(self):
		# do platform dependent stuff
		# create a static GUI element dictionary;
    	    	# show the login window
		# create the MainFrame		

def main():
	GNUmed client written in Python
	to run this application simply call main() or run the module as "main"
	#create an instance of our GNUmed main application
	#and enter the main event loop

gnumed.py calls gmGuiMain.main() 
gmGuiMain.main() creates gmApp
gmApp creates MainFrame
MainFrame sets up the toolbar, top row, Menus (items will be added by the plugins)
main sizers and loads all plugins in directory wxpython/gui

gmApp enters wx event loop, waiting for some action


</screen></sect2>
<sect2><title>gmAppoint.py</title><screen>
# gmAppoint - A simple interface to the appointments book.
#             INCOMPLETE, do not link in to rest of app.

</screen></sect2>
<sect2><title>gmCryptoWidget.py</title><screen>

This module implements a ""crypto"" aware text widget

This text widget allows arbitrary text to be entered via keyboard,
cut'n paste via clipboard, or text files via drag'n drop
Right clicking pops up a menu that allows to encrypt or decrypt
the selected text segment.

class gmTextctrlFileDropTarget(wxFileDropTarget):
     a generic text control widget that accepts dropped files 

    def __init__(self, textwindow):
    def OnDropFiles(self, x, y, filenames):
        inserts the dropped file(s) content(s) at the cursor position

class gmCryptoText(wxTextCtrl):
    A special text widget that supports cryptography

    A right mouse click pops up a manu that allows to encrypt
    or decrypt selected text segments.
    You can drag and drop any number of text files into the text
    widget, and that text will be inserted at the current cursor
    position

    def __init__(self, parent, id, size=wxPyDefaultSize, style=wxTE_MULTILINE|wxTE_RICH, defaulttext=None):

    def OnRightClick(self, event):
        A right mouse click triggers a popup menu for cryptographic
	functionality"

    def OnContextMenu(self, event):

    def OnEncrypt(self, event):
        triggered by popup contect menu event

    def OnDecrypt(self, event):
    def OnSetPassphrase(self, event):
    def OnRightDown(self, event):
        dummy function; if this event was not intercepted, GTK would
        clear the text selection the very moment the mouse button is clicked

    def AskForPassphrase(self):
        asks for a pass phrase and returns it

    def Encrypt(self, cleartext, key):
        override this function for your own crypto funcs

    def Decrypt(self, ciphertext, key, identtag):
        override this function for your own crypto funcs

    def StripIdentTag(self, text):
        Remove the 'ident tag' from text and return both tag and test
    def GetIdentTag(self):
        This is a 'virtual' function which should be overridden to provide your own meaningful tag

    def SetFuzzyMargin(self, margin):
        The fuzzy margin is the number of characters on each side of the text selection
        the decryption algorithm will search for correct delimiters. It should be at least as long as
        the IdentTag is plus an extra 3 characters to allow for the crypto tag

    def FuzzyScanSelection(self, frompos, topos, margin):

</screen></sect2>
<sect2><title>gmEditArea.py</title><screen>
The classes in this file are not used until now. 

class  EditAreaTextBox(wxTextCtrl):
#text control class to be later replaced by the gmPhraseWheel
	def __init__ (self, parent, id, wxDefaultPostion, wxDefaultSize):

class EditAreaPromptLabel(wxStaticText):
#Class which shows a blue bold label left justified
	def __init__(self, parent, id, prompt, aColor = richards_blue):

class EditAreaPrompts(wxPanel):
#create the editorprompts class which expects a dictionary of labels passed to it
#with prompts relevent to the editing area.
	def __init__(self,parent,id,prompt_array):

class EditTextBoxes(wxPanel):
#Class central to gnumed data input
#allows data entry of multiple different types.e.g scripts,
#referrals, measurements, recalls etc
#section = calling section eg allergies, script

have a look at the source code if you want to know what it is doing.

</screen></sect2>
<sect2><title>gmGuiElement_AlertCaptionPanel.py</title><screen>
base classes for captioned alert divider on left hand side of
notebook page "patient"
</screen></sect2>
<sect2><title>gmGuiElement_DividerCaptionPanel.py</title><screen>
base classes for captioned dividers on left hand side of
notebook page "patient"
</screen></sect2>
<sect2><title>gmGuiElement_HeadingCaptionPanel.py</title><screen>
base classes for captioned heading divider on left hand side of
notebook page "patient"

gmGuiMain.py
- inits wxPython GUI framework

</screen></sect2>
<sect2><title>gmLogFrame.py</title><screen>
not used anymore, really

</screen></sect2>
<sect2><title>gmLoginDialog.py</title><screen>
encapsulates the first dialog, the login window.
should be del()ed after use, actually

</screen></sect2>
<sect2><title>gmLogin.py</title><screen>
- encapsulates the login information as a python object

</screen></sect2>
<sect2><title>gmMDWImporter.py</title><screen>
- not related to framework
- implements data import from on commercial australian medical
  software

</screen></sect2>
<sect2><title>gmShadow.py</title><screen>
- encapsulates custom widget shadow object to be used on all
  Richard-Terry-Style widgets (possibly more)

</screen></sect2>
<sect2><title>gmTalkback.py</title><screen>
- encapsulates talkback app

</screen></sect2>
<sect2><title>gmUserAdmin.py</title><screen>
- unrelated to framework as of now
</screen>
</sect2>
</sect1>

<sect1><title>wxpython/gui - "whole page" plugin widgets regarding the notebook</title>
<para>TODO</para>
</sect1>
<sect1><title>wxpython/gui-de - same as ../gui for Germany (AMIS-browser should life here)</title>
<para>TODO</para>
</sect1>

<sect1><title>wxpython/patient - "patient page" plugin widgets</title>
<para>TODO</para>
</sect1>
	
</chapter>


    <chapter>
    	<title> Design </title>
	<sect1>
	    <title>GNUMed Database Architecture</title>
    	    <sect2>	
    	    	<title>Client-Server architecture with optional middleware layers</title>
    	    	<para>
    	    	GNUMed is designed as a <emphasis>client-server</emphasis> architecture with <emphasis>optional middleware</emphasis> components.
		The database backend is provided by PostgreSQL, a largely SQL-92 compliant  object-relational
		database server. PostgreSQL is free software, obtainable at http://www.postgresql.org. 
		It is portable, running on virtually all Posix compatible systems including Gnu/Linux, 
		BSD Unix, Solaris, Mac OS/X. Although we do not recommend it, it can be run on Microsoft
		Windows NT, 2000 and XP.
    	    	</para> 
    	    </sect2>
            <sect2>
	    	<title>Distribution of database services</title>
    	    	<para>
    	    	GNUMed allows distributions of database services. Closely related information like a person's
		name and address are regarded as a "service", which may or may not be hosted on the same physical 
		server as other services. Developers have to refer to the list of services when designing database 
		queries. A <emphasis>central pivot database</emphasis> provides information about the nature and whereabouts of 
		distributed services. On the client side, distribution is made transparent to the developer
		and end user through a <emphasis>"database service broker"</emphasis> object which not only hides information about
		service distribution, but can also be used for load balancing , reusable connections and database
		replication in future versions. 
    	    	</para>
	    </sect2>
    	    <sect2>
	    	<title>Normalization of data</title>
    	    	<para>
    	    	Tables are <emphasis>normalized</emphasis> to the  3rd normal form as long as this does not deteriorate query performance
		too much. In order to simplify client software development, a <emphasis>pseudo-denormalization</emphasis> is achieved through
		updateable views. Foreign key constraints ensure <emphasis>referential integrity</emphasis> of highly normalized data.
		Reference counter tables keep track of <emphasis>cross-database relational integrity</emphasis>, as PostgreSQL does not allow
		(yet) cross-database constraints and queries.
		</para>
    	    </sect2>
    	    <sect2>
	    	<title>Audit trailing</title>
    	    	<para>
    	    	<emphasis>Trigger functions</emphasis> ensure business logic and <emphasis>audit trailing</emphasis> . Deleting and updating of data is caught by
		triggers, and copies of the originals are kept in audit trail tables at all times. Database programmers
		need not to worry about this, as all audit trail related triggers and tables are generated automatically.
		In order to achieve this, we do use postgres specific extensions such as table inheritance and built-in 
		procedural languages such as pgsql, pgtcl and pgpython. Thus, gnumed can not be
    	    	easily ported to a different database backend.
    	    	</para>
    	    </sect2>
    	    <sect2>
	    	<title>Access control</title>
    	    	<para>
    	    	The PostgreSQL server supports <emphasis>secure authentication protocols</emphasis> such as Kerberos as well as <emphasis>secure
		communication protocols</emphasis> between client and server(s) such as SSL. In addition, data of more strictly
		confidential data wil be stored encrypted with arbitrary algorithms; although the cryptographic process
		is performed on the client side, this is supported by the GNUMed server through a sophisticated key management.
		A user hierarchy can be implemented, and access to tables and procedures can be regulated through this hierarchy
		on the server side.
    	    	</para>
	    </sect2>	
    	    <sect2>
	    <title>Multigenerational concurrency control and backups</title>
    	    <para>
    	    PostgreSQL uses a multigenerational concurrency control system. This not only avoids most locking situations,
	    but also allows <emphasis>life "snapshot" backups</emphasis> of the complete database system while the system is running even under
	    full load.
	    </para>
	    </sect2>
    	</sect1>


	<sect1>
	    <title>List of distributed database services</title>
    	    <sect2>
	    <title>Configuration - the service administering all other services</title>
	    <para></para>
	    </sect2>	

    	    <sect2>
    	    	<title>Person related services</title> 

    	    	<informaltable frame=all>
    	    	    <tgroup cols=2>
    	    	    <colspec colwidth="1*">
    	    	    <colspec colwidth="5*">
    	    	    <tbody>
    	    	    	<row><entry>Service name:</entry><entry>Personalia</entry></row>
    	    	    	<row><entry>Provides:</entry>
    	    	    	    <entry><itemizedlist mark=opencircle>
    	    	    	    	<listitem><para>
    	    	                    All information directly related to a person's identity, biological and social relationships
                    	    	    excluding confidential data (like credit card information) 
				</para></listitem>
				<listitem><para>
    				    All geographical information, including  
				</para></listitem>
				<listitem><para>
                		    Personal communication related information (phone numbers, fax, email, web sites, pagers) 
				</para>
				</listitem>
				</itemizedlist></entry></row>
    	    	    	<row><entry>Access level:</entry><entry>all staff</entry></row>
    	    	    </tbody>
    	    	    </tgroup>
		    <tgroup cols=3>
			<colspec colwidth="1*">
			<colspec colwidth="1*">
			<colspec colwidth="3*">
			<tbody>
			    <row><entry>Related Scripts:</entry><entry>gnumed.sql</entry>
			    <entry> priming of database (creation of procedural languages, basic access
                                    permissions, audit trail priming)
			    </entry></row>
			    <row><entry></entry><entry>gmgis.sql</entry><entry>
                            	    geographic information in the widest sense; streets, cities, states, nations,
                            	    postcodes ...
			    </entry></row>
			    <row><entry></entry><entry>gmidentity.sql</entry><entry>
                            	    a person's identity, names, relationships, and a many-to-many pivot table
                            	    linking identities to addresses
			    </entry></row>
			    <row><entry></entry><entry>gmcommunication.sql</entry><entry>
                            	    phone & fax numbers, email addresses, web sites, pagers, etc. and a
                            	    many-to-many pivot table linking identities to communication URLs
			    </entry></row>
			</tbody>
		    </tgroup>
    	    	</informaltable>

	    </sect2>	

    	    <sect2>
        	<title>Medical history related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    past medical  history / diagnoses 
		    </para></listitem>
		    <listitem><para>
		    active medical problems
		    </para></listitem>
		    <listitem><para>
		    progress reports
		    </para></listitem>
		    <listitem><para>
		    social history 
		    </para></listitem>
		    <listitem><para>
		    family history 
		    </para></listitem>
		    <listitem><para>
		    substance abuse history 
		    </para></listitem>
		    <listitem><para>
		    allergies 
		    </para></listitem>
		    <listitem><para>
		    vaccinations
		    </para></listitem>
		    <listitem><para>
		    past medication & current prescriptions
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>External results </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    pathology results 
		    </para></listitem>
		    <listitem><para>
		    imaging results
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>Correspondence </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    sent documents (referrals, certificates) 
		    </para></listitem>
		    <listitem><para>
		    received documents (discharge summaries, specialist reports)
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>Pharmaceutical reference </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    drug listing: generic and brand names 
		    </para></listitem>
		    <listitem><para>
		    drug properties 
		    </para></listitem>
		    <listitem><para>
		    consumer product information  
		    </para></listitem>
		    <listitem><para>
		    interactions
		    </para></listitem>
		</orderedlist>
	    </sect2>	
    	    
	    <sect2>
    	    	<title>General medical reference </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    coding (i.e. LOINC, ICD-10)
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	    	<title>Decision support database </title>
    	    	<para></para>
	    </sect2>	
    	    
	    <sect2>
    	        <title>Large binary objects (BLOBS)</title>
    	    	<para></para>
	    </sect2>	
    	    
	    <sect2>
    	        <title>Accounting related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    billing 
		    </para></listitem>
		    <listitem><para>
		    tax related information 
		    </para></listitem>
		    <listitem><para>
		    stock tracking
		    </para></listitem>
		    <listitem><para>
		    ordering supplies
		    </para></listitem>
		</orderedlist>
	    </sect2>	
    	    <sect2>
    	       <title>Office related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    waiting room 
		    </para></listitem>
		    <listitem><para>
		    appointments 
		    </para></listitem>
		    <listitem><para>
		    recalls 
		    </para></listitem>
		</orderedlist>
    	    </sect2>
    	</sect1>	


    	<sect1>
	    <title>Internal Messenging and Signal Dispatching</title>


	    <sect2>
		<title>Internal Messenging and Signal Dispatching</title>

	    <para>The gnumed client depends on two different types 
	    of messages:</para>

	    <orderedlist numeration="arabic">
		<listitem><para>Messages coming form the backend. Example: &nbsp;a receptionist queues 
	     patients as they arrive into a waiting room widget. On the doctors screen 
	     there should be a small widget informing him about the number of patients 
	     waiting for him. This is achieved through asynchronous messages from the backend.</para></listitem>
		<listitem><para>Client-internal messages. They allow widgets to communicate. Example: 
	     One widget allows the doctor to select the active patient. This widget, after 
	     selection, has to notify other widgets depending on this information (like 
	     widgets displaying the patients past medical history, his allergies etc.) 
	      to update themselves.</para></listitem>

	    </orderedlist><para>
	     Both types of messages are handled via a global dispatcher module called 
	    <link linkend=gmDispatcher> gmDispatcher.py </link>
	     The module <link linkend=gmPG>gmPG.py </link>
    	    takes care of handling the asynchronous messages from the backend 
	    via a separate background thread.</para><para>
	     </para><para>
	     Procedure changing "global" data that may affect any other widget, must
	    post a message through gmDispatcher.</para><para>
	     </para><para>
	     Widgets depending on backend data must register their interest through gmDispatcher.</para><para>
	     </para><para>
	     A  table listing all available message labels
	      ("signals") and their meanings can be found <link linkend=signals>here.</link>
	      However, these message strings should never be hardcoded. Developers must 
	    instead use the embedding variables as listed in the module <link linkend=gmSignals>gmSignals.py </link>.</para><para>
	     </para><para>
	     Developers writing code that creates new signals must
	     update this webpage via CVS.</para><para>
	     </para><para>

	    <emphasis>Examples:</emphasis>

	    <orderedlist numeration="arabic">
	    	<listitem><para>A widget allows to select the current patient.
	     	    <orderedlist numeration="arabic">
		    <listitem><para>It first registers it's interest in all patients added, modified
		    or deleted with the backend as it should always be able to display the most
		    current status of the backend data. For that purpose, it defines a callback
		    function "self.OnDemographicsUpdated()".</para></listitem>
    		    
		    <listitem><para>Then, it registers this callback function with the dispatcher for
		    all signals that would modify the patient database.  </para><para>
		    If anybody within a gnumed system modifies demographic information, this
		    widget would be automatically notified about this.  </para><para>
		    </para></listitem>
		    
		    <listitem><para>Once the user has interactively selected a patient, it has to alert
		    all other widgets that this has happened. For that purpose, the event handler
		    reacting to a patient being selected notifies the gmDispatcher about this. 
		    </para><para>
    	    	    	<screen>
     def __init__(self):

         #register our interest in the&nbsp;patients stored on the backend

         gmDispatcher.connect(self.OnDemographicsUpdated, gmSignals.demographics_updated())

        	     	</screen>
    	    	    	<screen>        	     
    def OnDemographicsUpdated(self, id):
	"when the patients have changed on the backed, update the ones we display"

        #id is irrelevant here; we just update the whole displayed list

        self.UpdatePatientList()
        	        </screen>
        	     
    	    	    	<screen>        	     
    def UpdatePatientList(self):
	"Update the displayed list of patients from the backend"

      #request a backend connection

      db = gmPG.ConnectionPool().GetConnection('demographica')

      cursor = db.cursor()

      #query patients to be displayed

      cursor.execute(....)

      result = cursor.fetchall()

      #display the result
    	    	    	</screen>
        		  
        	       
        	     	<screen>
     def OnPatientSelected(self, id):
	 """When a patient has been selected by the user, call this function     
	 id is the primary key identifying the selected patient"""     

    	 gmDispatcher.send(gmSignals.patient_selected(), id=id)
    	    	    	</screen>    	       
        	     
		 </para></listitem>

	      </orderedlist>
	      </para></listitem>
	      <listitem><para>Another widget displays the current (active) patient's name.&nbsp;

	      <orderedlist numeration="arabic">

		<listitem><para>Thus, it has to register it's interest in the event the current patient
	    changes. The registered callback could query the database directly. However,
	    data that is likely to be shared among many widgets, should be cached to
	    avoid unneccessary backend traffic and to improve client performance. Thus,
	    it requests the data from the gmCachedPerson.CachedPerson object:
      <screen>
      def __init__(self):
        #code to display and place the widget
        # now register our callback function with the dispatcher
        gmDispatcher.connect(self.Update, gmSignals.patient_selected())
      </screen>

      <screen>
      def Update(self, id_patient):
        "show the currently selected patient"
        patient = gmCachedPerson.CachedPerson.dictresult()
        self.TxtctrlSurname.SetValue(patient['surname']
        ....
      </screen>
		</para></listitem>
	      </orderedlist>
    	      </para></listitem>
	    </orderedlist>

    	</sect1>


    	<sect1 id=signals>
	    <title>List of GnuMed client internal signals</title>
                    
    	    <para>         
	    All signals are defined in the module gmSignals.py, located in the source
	    tree under gnumed/client/python-common.</para>
	    <para>
	    Developers never should use these signal strings directly, but always refer
	    to the signal strings via their factory functions in the module gmSignals.</para>
	    <para>
	    The name of the factory function is identical with the signal it represents:
	    gmSignals.popup_notice() would thus return the string 'popup_notice'.
	    </para>
	    <para>
	    However, these factory functions <emphasis>may</emphasis> do more than just that; they
	    can also trigger a 'listen' signal for asynchronous backend notifications,
	    and they can do some house keeping in order to avoid that the same callback
	    is triggered multiple times unneccessarily.
	    </para>

    	    <para>
		<table frame=all>
		<title>Signals</title>
		<tgroup cols=4>
		    <colspec colname=c1>
		    <colspec colname=c2>
		    <colspec colname=c3>
		    <colspec colname=c4>
		    <spanspec spanname=hspan namest=c1 nameend=c4 align=center>
		    <thead>
			<row>
			    <entry>Signal</entry>
			    <entry>Meaning</entry>
			    <entry>Parameter(s)</entry>
			    <entry>Origin</entry>
			</row>
		    </thead>
	      	    <tbody>

		    <row><entry spanname=hspan><emphasis>General messages</emphasis></entry></row>
    	    	    <row>
			<entry>popup_notice</entry>
        		<entry>A popup notice wants to be displayed (can be disabled if 
			client does not want to be interrupted)</entry>
        		<entry><itemizedlist mark=closedcircle>
		    	    <listitem><para>id_sender (ID of sender)</para></listitem>
		    	    <listitem><para>id_recipients ( IDs of recipients  as list (-1 = broadcast message))</para></listitem>
			</itemizedlist></entry>
        		<entry>Frontend or Backend</entry>
		    </row>
        	    <row>
        	    	<entry>popup_alert</entry>
        	    	<entry>A popup alert wants to be displayed (high priority 
			message - should not be disabled by the client)</entry>
        	    	<entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_sender (ID of sender) id_recipients</para></listitem>
			    <listitem><para>( IDs of recipients  as list (-1 = broadcast message))</para></listitem>
			    </itemizedlist></entry>
        	    	<entry>Frontend or Backend</entry>
		    </row>

		    <row><entry spanname=hspan><emphasis>"Current patient" related messages</emphasis></entry></row>
		    <row>
        		<entry>patient_selected</entry>
        		<entry>A patient has been selected within the client user interface. This 
			 patient is now the "current" patient. All widgets displaying client data
			 must update themselves accordingly</entry>
        		 <entry>id_patient (ID of patient)</entry>
        		 <entry>Frontend</entry>
		   </row>
		   <row>
        	     <entry>patient_modified</entry>
        	     <entry>A patient's demographic data has been updated. Widgets displaying a
		      patient's demographic data must update themselves</entry>
        	     <entry>id_patient (ID of patient)</entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		   <row>
        	     <entry>medication_modified</entry>
        	     <entry>The current patient's medication has been modified. Medication related
		      widgets have to update themselves. This can also be used for drug interaction
		      checking, drug allergy checking etc. </entry>
        	     <entry>id_patient (ID of patient)</entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
    	    	    
		    <row><entry spanname=hspan><emphasis>Waiting room related</emphasis></entry></row>
		   <row>
        	     <entry>waitingroom_added</entry>
        	     <entry>A patient has been added to the waiting room</entry>
        	     <entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_patient (ID of patient)</para></listitem>
			    <listitem><para>id_doctor (ID of doctor to see patient)</para></listitem>
	    	     </itemizedlist></entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		   <row>
        	     <entry>waitingroom_incons</entry>
        	     <entry>A patient has entered a consultation (is seen by a doctor)</entry>
        	     <entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_patient (ID of patient)</para></listitem>
			    <listitem><para>id_doctor (ID of doctor to see patient)</para></listitem>
		     </itemizedlist></entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		   <row>
        	     <entry>waitingroom_left</entry>
        	     <entry>A patient has left the waitingroom (finished consultation)</entry>
        	     <entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_patient (ID of patient)</para></listitem>
			    <listitem><para>id_doctor (ID of doctor to see patient)</para></listitem>
		     </itemizedlist></entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		</tbody>
        	</tgroup>
		</table>
    	</sect1>

	<sect1>
	<title>FAQ</title>
    	<para>
> I would be interested in hearing about the database design 
> history and the purpose of the distributed database architecture
> that you have implemented, (smart, but possibly a little 
> over-kill I would have thought at first glance).
    	    </para>
	    <para>
	    Horst Herb:The main reason why we had to split the monolithic backend up:
- some countries provide centralized demographic information. It would 
be inefficient and unreliable to try to copy such a centrally well 
maintained demographic database. We should rather allow to tap into it 
via distributed services.
- some countries provide centralized pharmaceutical information
- some countries provide centralized immunisation databases
- some conutries centralize certain pathology results
etc.

Sometimes, this happens on a smaller scale like within a hospital where 
they already have successfully implemented some of these services, they 
are running smoothly, and they find no reason to pull it apart again. 
GNUMed will shine in such an environment because it will be far easier 
to integrate into such existing solutions than other software.

Thus we try to find out which "services" are relatively independent from 
others, and isolate them into particular "virtual" databases. That 
way, it will be magnitudes easier to write simple wrappers for external 
sources and use them.

The main obstacle is tha Postgres in itself does not support 
cross-database queries, and we have to take care of referential 
integrity between external sources ourselves.

Note: we should put in a description on how this is achieved now
(client side) vs. how we would want this (either built into postgres
or via a dedicated demon on the backend with listen/notify)
	    </para>
	    
	    <para>
	    Karsten Hilbert: 
There isn't really much choice: Doing everything in one
monolithic database isn't quite flexible enough (distributed
practices with a WAN link, remote clinical repository but
local drug information data store). The difference between
hardcoding 2 or 3 database and doing it the Right Way as we
are trying to do now isn't very much of a difference. So there
aren't really many steps inbetween "monolithic" and
"distributed according to some configuration". Yes, it's a bit
more complex but to the client side it shouldn't be any more
complex than:

dbbrooker.GetConnection('personalia')
dbbrooker.GetConnection('BLOBS')

If we then properly encapsulate accesses into objects we don't
experience too much pain in using the distributed version.

It does get a bit more involved with keeping strict
referential integrity across databases but Horst can explain
the issues better than me.
    	    </para>
	    
	</sect1>

	<sect1>
	    <title>GUI design</title>

    	    <sect2>
		<title>General</title>
	    	<para> (Taken from Richards Terrys Design Philosophy at www.gnumed.net/rterry)</para>
		<itemizedlist mark=opencircle>
		   <listitem><para>Uncluttered screen without wasting screen real estate.</para></listitem>
		   
		   <listitem><para>Pleasant, aesthetic view.</para></listitem>
		   
		   <listitem><para>As few as possible pop-up elements; static screen elements should be given preference.</para></listitem>

		    <listitem><para>
		      As few as possible modal forms. Data belonging together should be on the same visual plane. Peripheral information should not distract the attention attention.
		    </para></listitem>

		    <listitem><para>
		      Core information (eg medications, tasks to do during consultations, recalls etc) should be visible while working in different sections.  		      
		    </para></listitem>

		    <listitem><para>Use of colors to highlight and separate information. The use of colors should be customizable.
		    </para></listitem>

		    <listitem><para>
		    Data entry and presentation should follow a recurring pattern. The same type of information should be displayed and entered at the same place in different sections where possible.
		    </para></listitem>

		    <listitem><para>
		      Program control: Primarily keyboard oriented control, every action should be accessible via keyboard shortcuts
		      Mouse oriented control must be possible, too.
		    </para></listitem>
		    <listitem><para>Ease of use:
		      Only very few steps to find an option. Key strokes should be kept to a minimum.key strokes should be kept to a minimum,
		      there should be no heavy reliance on menu's. 
    	    	    </para></listitem>
		    <listitem><para>Customizability: The program should provide the user with timely and appropriate information in his style and language. 
		    </para></listitem>
		    <listitem><para>Contextual and weighted data presentation: If possible, information should be presented in a weighted and contextual fashion. Statistics about information use should be collected in these cases.
		    </para></listitem>

		  </itemizedlist>


    	    	<sect3>
		    <title>Date Entry Paradigm - The Editing Area</title> 
		    <para>Medical information usually can be presented as groups of 4-10 parameters. 
		    It is therefore possible to come up with a gui design for data entry where 
		      all segments of a medical records program use the same format of data input. 
		    In GnuMed this fact is reflected by a graphic 
		      design that is called the 'editing area'. 
		    </para>

		    <para>The area of the screen where data is entered (`editing area) will be implemented as an widget which can be customized to the various groups of medical information. </para>
		      <para>This editing area does not 'pop up' in a window. It stays in the same place 
		      on the screen but changes appearance according to the type of data the user 
		      is entering.</para>
		    <para> Because it looks and functions the same, no matter 
		      what category of data is being entered, there is no need to for the user to 
		      learn how to use multiple sections of a program, no need to have multiple different 
		      designs of pop up dialogs as is common in most medical programs.</para>
		    <para>In addition, as a programmer will quickly realise, 
		      it can lead to a reduction in computer code needed to generate the display and 
		      call in information from the database for contextual display, as generic subroutines 
		      can be developed to work across all sections of medical information. </para>
		    <para>In most sections of the program the user enters 
		      very little information as most of it will be 'autofilled' in by the program. In GnuMed, The 
		      context of the editing area can be called from a button bar. </para>
		  
		    <para>In the following there are shown some examples of it's implementation. 
		      These screen dumps have been taken from an already functional VisualBasic-based medical records program written by Richard Terry. 
		      The graphical interface of GnuMed will be quite similiar to that of some of the examples shown.
		      First examples of variations of the editing area, followed by screen 
		      dumps of the whole program, accompanied by comments by Richard Terry.</para>
    	    	</sect3>
		
		<sect3>
		    <title>Full Screen Design</title>
		    <para>The following is the rough 
		      template used for designing the whole screen. The proportions are roughly 
		      shown below.</para>
		    <para>
		      Though the area designated 
		      for the tab control (which contains lists for medications, pathology, referral 
		      letters, recalls etc) may seem small, in practice it works well. There is enough 
		      room here for eg 10-14 medications and if filled, that in itself would indicate 
		      the patient was probably suffering from poly-pharmacy!. Other lists eg pathology 
		      are viewed in decending order, ie most recent to least recent, and are usually 
		      able to be sorted by date/type of request etc hence information is easily seen 
		      or quickly found. Just how many requests/referrals/recalls does the average 
		      patient have in year anyway, usually very few.</para>
		    <para>The 'scratch pad' area I've found immensely useful. 
		      The doctor enters free hand text here for those little reminders one needs which 
		      may not be 'medical reminders' or could be personal memory joggers for the doctor.</para>
		    <para>The lower right hand area contains any outstanding 
		      reviews/recalls which are presented as the recall name and months due/overdue.</para>
		    <para>The size of the left hand rectangle (which here 
		      contains the editing area and some lists) is large enough and proportionately 
		      sized enough to display a variety of information e.g. referral letter text, 
		      pathology results, imaging results, graphs with decision support. I.e, one could 
 clicking on the drug display 
		      its product information, or if browsing the pathology list display the results 
		      of a test in this area</para>
		    <para>The editing area always occupies the central portion 
		      of this area and changes display according to the section of the program one 
		      is working on, although it may at times be temporarily covered by a display 
		      which uses the whole of this left hand pane.</para>
		    <para>The best way to see how this all works is to view 
		      the screen dumps shown on the following pages.</para>
		    <screenshot><graphic fileref="snapshots/Full_screen-general_description.png"></graphic>
		    </screenshot>		
		</sect3>
    	    </sect2>
	</sect1>

    	<sect1>
	    <title>Login Screen</title>
	    <sect2>
		<title>Short description</title>

    		<para>
		User authentication , possibility to choose login options.
		</para>

    	    </sect2>

	    <sect2>
		<title>Data Shown/Accessible</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>user name [free text]</para></listitem>
		    <listitem><para>user password [free text]</para></listitem>
		    <listitem><para>GnuMed database name [free text, choose from list]</para></listitem>
		    <listitem><para>GnuMed database host name [free text, choose from list]</para></listitem>
		    <listitem><para>GnuMed database host port [free text, choose from list]</para></listitem>
		    <listitem><para>GnuMed database options [free text, choose from list]</para></listitem>
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Functionality</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Get user name and password</para></listitem>
		    <listitem><para>Change GnuMed database options (database name, host, port of database server, database options)</para></listitem>
		    <listitem><para>Try to start GnuMed using the given user and options.</para></listitem>
		    <listitem><para>Remember the user/options used at the last login attempt.</para></listitem>
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Internals / Additional Information</title>
		<para>
		GNUMeds design allow connection to arbitrary servers. The server of choice is simply
		entered into the "host" text entry field. This is handy to connect to a replicated backup server in case
		of a failure of the primary server. It also allows to replicate the database onto the workstation
		and work separated from the net. As we are using TCP/IP (with optional SSL/TL secure protocol layers,
		the server can be located anywhere in the world. This allows for example a doctor to access a visiting patient's
		health record without importing / exporting data first. It also allows for centralized  record keeping in
		practices with multiple locations, or it allows a doctor to access his records from home.
		</para>

		<para>
		After entering the password and hitting enter (or after clicking onto the login button), the client attempts
		a server backend connection. If successful, the connection is logged and the GnuMed main screen displayed. The users
		preferences are loaded and the client configured accordingly. This can involve a complete reconfiguration
		of the client user interface. As the client remembers the last state before
		it was closed the last time, no configuration will be neccessary (unless it involves confidential settings)
		if always the same user uses this particular workstation.
		</para>

		<para>
		After a succesful login (and succesful user configuration) the first page of the notebook is opened automatically
		and the cursor is placed inthe "patient selector" search expression combo box, ready to search for a specific patient.
		</para>

    	    </sect2>

    	</sect1>

    	<sect1>
	<title>Main Toolbar</title>

	    <sect2>
		<title>Short Description</title>

    		<para>
		Toolbar which is always present and holds menus, icons to change tools and generally important information.
		</para>

    	    </sect2>

	    <sect2>
		<title>Data Shown/Accessible</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Menus of all notebook pages / tools etc [scroll down menus]</para></listitem>
		    <listitem><para>Tool bar specific to the current module (notebook page) [icons]</para></listitem>
		    <listitem><para>Generally important information specific to the current module such as patient photo, name, allergies in the 'patient' module [various]</para></listitem>			
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Functionality</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Hold all menus.</para></listitem>
		    <listitem><para>Hold tool icons and generally important information specific to the current module</para></listitem>
		</itemizedlist>
    	    </sect2>

    	    <sect2>
	    <title>Internals / Additional Information</title>
	    <para>
	    <emphasis>The patient photo:</emphasis> if available, the most recent photograph of the patient will be displayed.
	    Clicking on the photograph will open the patient details notebook page below. A right click will reveal
	    a menu allowing to browse other photographs of this patient.
	    </para>

	    <para>
	    <emphasis>Personal details</emphasis>: The most important items from the personal details of the patient. Configurable.
	    </para>
	    <para>
	    <emphasis>Allergies &amp;</emphasis> Warnings Configurable. Colour coding etc. available to discretely display warnings like
	    "drug seeking behaviour"
	    </para>

	    <para>
	    <emphasis>The main notebook :</emphasis> The notebook design has been chosen in order to avoid annoying popup
	    dialogues. The order of the notebook pages is user configurable. The first page of the notebook
	    is the login screen. As most user settings are stored on the database backend, the gnumed client will
	    not be functional before the backend connection has happened.
	    </para>

        </sect2>
    	</sect1>
	
    	<sect1>
	    <title>Appointment book</title>    	
    	    <sect2>
		<title>Functionality</title>
    		<para>The appointment book is aimed for front-desk staff. &nbsp;It allows to
		make, edit and cancel appointments.
		The doctors can view the appointment list too (who is in the waiting room?)
		or give appointments without interfering with the receptionists. It can be
		used as a time tracking tool, too as it allows to keep track of when a patient
		</para>
		<itemizedlist mark=opencircle>
		  <listitem><para>has booked</para></listitem>
		  <listitem><para>for when he has been booked</para></listitem>
		  <listitem><para>when the patient arrived</para></listitem>
		  <listitem><para>when and how long the patient has been seen</para></listitem>
		</itemizedlist>
    		<para>
		It also can fill in as a interface towards the billing package.
    		</para>
	    </sect2>

    	    <sect2>  
    	    <title>The "schedule widget"</title>
  
		<para>
		Central unit of the appoinment book is the schedule widget - a spreadsheet
		like GUI control. Within the appointment book framework, any number of schedules
		can be displayed simultaneously (for example one for each doctor in a practice).
		Date selection controls in the framework sterr all schedule widgets simultaneously
		- taht allows to quickly page through the weeks to see which doctor could
		still fit a patient in.
		</para>
		<para>"Today" is marked yellow, weekend days pink, and days where a doctor is
		not available are marked in grey. Of course, all colours are configurable.</para>
		<para>Data entry is simple &amp; efficient: after selecting a vacant time slot
		, one starts typing a few characters of a surname; if there might be many
		patients with the same surname, one can enter a few characters of a given
		name too, separated by a space. If the appointment should be longer than
		standard, keying in a '+' for each pre-defined increment will do the trick.
		 On Enter, a small dialogue pops up and takes obver the cursor. It displays
		all matches from the patient data base (matching surname fraction and optionally
		given name fraction), the cursor is already positioned on the first entry.
		Enter confirms, cursor keys move the selection, Alt-n allows to enter a new
		patient. Thus, in the most common cse the appointment is made with 5-6 keystrokes
		: 2 first characters of the surname, 2 first characters of the given name,
		Enter.
		</para>
		<screenshot>
		<screeninfo>"Schedule for one doctor with patient selector open. Size 679x815"</screeninfo>
		<graphic fileref="snapshots/schedule-mono.png"> </graphic>
		</screenshot>
    	    	</sect2>  

		<sect2>
		    <title>Calendar navigation</title>
		    <para>A few convenience buttons allow navigation between weeks and months around
		    the current date with a single keystroke or mouse click. For more demanding
		    date entry, a calendar popup is provided. Alt+c pops it up, cursor keys select,
		    enter confirms. alternatively, the mouse can be used.
		    </para>
		    <screenshot>
		    <screeninfo>"Schedule for 2 doctors with calendar widget active Size 1020x824"</screeninfo>
		    <graphic fileref="snapshots/schedule.png"></graphic>
		    </screenshot>

		    <para>
		    This images displays two doctors simultaneously. Any number of doctors can
		    be displayed, provided the screen is large enough for satisfactory visualization.
		    Alternatively, each schedule widget has a combo box on top which allows to
		    select any doctor available.
		    </para>
    	    	</sect2>  

    	    	<sect2>
		    <title>Context sensitive popup menus</title>

		    <screenshot>
		    <screeninfo>"Popup menu for a booked patient. Size 402x359"</screeninfo>
		    <graphic fileref="snapshots/appointment-popup-menu.png"></graphic>
		    </screenshot>
    
    	    	    <para>
		    By right clicking a cell (or typing Alt-o) a popup menu will offer a few
		    choices what else we can do with the booked patient. This is expandable via
		    plugin architecture.
    	    	    </para>
    	    	</sect2>

    	    	<sect2>
    	    	    <title>TO DO:</title>
 
		    <itemizedlist mark=opencircle>
			<listitem><para>testing</para></listitem>
			<listitem><para>write proper documentation</para></listitem>
			<listitem><para>popup menu functions not implemented yet</para></listitem>
			<listitem><para>new patient dialog not implemented yet</para></listitem>
			<listitem><para>billing package needs to be written</para></listitem>
			<listitem><para>printing</para></listitem>
		    </itemizedlist>
    	    	</sect2>    	    	
    	</sect1>	


</book>
