<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<book>
   <bookinfo>
     <date>2002-09-03</date>
     <title>GNUMed</title>
     <subtitle>Developers's Manual</subtitle>
    
	<author>	
      		<firstname>Gerardo</firstname>
		<surname>Arnaez</surname>
      	</author>

     	<author>	
      		<firstname>Hilmar</firstname>
		<surname>Berger</surname>
    	</author>


<abstract>
	<para>      
      Copyright (c) 2001,2002 GNUMed developers</para>
      <para>
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, with no
      Front-Cover Texts, and with no Back-Cover Texts.</para>
      <para>
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</para>
   </abstract>

<revhistory>
      <revision>
	<revnumber>0.1.4</revnumber>
	<date>2002-07-29</date>
	<authorinitials>hb</authorinitials>
	<revremark>added EMR,table auditing, drug browser documentation, updates</revremark>
      </revision>
      <revision>
	<revnumber>0.1.3</revnumber>
	<date>2002-12-25</date>
	<authorinitials>hb</authorinitials>
	<revremark>Added I18N,SQL-guidelines, config hints</revremark>
      </revision>

      <revision>
	<revnumber>0.1.2</revnumber>
	<date>2002-09-13</date>
	<authorinitials>hb</authorinitials>
	<revremark>Further inclusion of gnumed whitepapers.</revremark>
      </revision>

      <revision>
	<revnumber>0.1.1</revnumber>
	<date>2002-08-12</date>
	<authorinitials>hb</authorinitials>
	<revremark>Added some basic description of gnumed client modules.</revremark>
      </revision>

      <revision>
	<revnumber>0.1</revnumber>
	<date>2002-08-03</date>
	<authorinitials>gea</authorinitials>
	<revremark>Initial developers manual written, mostly will copy from savanah.gnu.org</revremark>
      </revision>


    </revhistory>


   </bookinfo>
   <toc></toc>

<preface id=preface>
	<title>Preface</title>
	<para>GnuMed never sleeps.</para>
</preface>

    <chapter id="intro">
     	<title>Introduction</title>
	<para>GNUMed is  a comprehensive scalable software solution for paperless 
	medical practice with emphasis on privacy protection, secure patient-centric 
	record sharing, decision support and ease of use.
	</para>
	<para>GNUMed is not yet ready for download as a package.
	It will become available at 
	<ulink url="http://gnumed.org/">
	<citetitle>gnumed.org</citetitle></ulink>.

	It is released under the GNU 
	General Public Licence, see the file <filename>LICENCE</filename> for details.
	</para>
    </chapter>

  <chapter id=cvs>
    <title>Checking out, Checking in GnuMed CVS</title>
    <sect1 id=cvs-access>
      <title>Developer CVS Access via SSH (Version 1, RSA)</title>
      <para>Only project developers can access the CVS tree via this method. SSH1 must be installed on your client machine. If you have SSH version two, add
	<screen>Host subversions.gnu.org
Protocol 1</screen>
      </para>
      <para>In my case, I simply re-installed ssh, and made sure both Protcol 1 and 2 were allowed and then put in <screen>Protocol 1,2</screen> in my <emphasis>~/.ssh/config</emphasis> file.
      </para>

      <para>Getting a ssh1 key is quite simple. You may either use an already existing ssh1-key (e.g. the one you already use to encrypt/sign your mail) or create a new one. </para>

      <sect2>
      	<title> Use an existing ssh1-key </title>
      	<para>
      	Copy the contents of the public part of the key (usually the file ~/.ssh/identity.pub to the ssh-key text field at Savannah (see below).
      	Add the line <screen>export CVS_RSH=ssh</screen> to your .profile.
      	</para>
      </sect2>
      <sect2>
      	<title> Create a new ssh1-key (using OpenSSH) </title>
      	<procedure>
	    <step>
	    	<para>
      	    	<screen> ssh-keygen [-i ~/.ssh/key_file_name] -t rsa1  </screen>
      	    	key_file_name is the name of the key you want to create. If you want to create your primary key (the key you want to use for mail etc.) you can drop the part in brackets. In this case you will find the key file in ~/.ssh/identity.pub.
      	    	</para>
	    </step>
	    <step>
      	    	<para>
      	    	Then copy and paste the contents of the public part of the key (the file ~/.ssh/key_file_name.pub to the ssh-key text field at Savannah (see below). Be sure not to copy line breaks.
		</para>
	    </step>
	    <step>
      	    	<para>
      	    	If you created a your primary key,add the line <screen>export CVS_RSH=ssh</screen> to your .profile.
      	    	</para>
		<para>
		If you created a new key particularly for the cvs, enter the following lines
		<screen> echo "#! /bin/sh\nssh -i ~/.ssh/key_file_name $@" > ~/bin/ssh_cvs
chmod +x ~/bin/ssh_cvs
    	    	</screen>
    	    	Add the line <screen>export CVS_RSH=ssh_cvs</screen> to your .profile.		
    	    	</para>
	    </step>
	</procedure>
	</sect2>
	<sect2>
	    <title> Uploading your SSH1-Key </title>
	    <para> Copy and paste the public part of the ssh1-key to savannah.gnu.org using https://savannah.gnu.org/account/editsshkeys.php.
	    </para>
	</sect2>
    </sect1>
    <sect1 id=cvs-basic-commands>
      <title>Basic commands</title>
      <para>Again just making it clear</para>
      <para>To Checkout CVS as a developer, you will type:</para>
      <screen>cvs -z3 -d<emphasis>dude</emphasis>@subversions.gnu.org:/cvsroot/gnumed/ co gnumed</screen>

      <para>To update your tree, you will type:
      <screen>cvs -z3 -ddude@subversions.gnu.org:/cvsroot/gnumed/ update -d [-P] gnumed
      </screen>
      You might want to use the -P option, which removes empty directories from your copy of the CVS.	
      </para>
      <para>To commit your changes, type:</para>
      <screen>cvs -z3 -ddude@subversions.gnu.org:/cvsroot/gnumed/ commit gnumed</screen>
      <para>Remember that you will be asked for your passphrase. This is different from 
      your password to savannah.gnu.org</para>
    </sect1>
  </chapter>

  <chapter id=guidelines>
    <title>Coding Guidelines</title>

    <sect1 id=cvs-guidelines>
      <title>CVS Guidelines</title>
      <para>Always test before you check in (yes, I have been guilty of not heeding 
      my own advice, sorry)
      </para>
      <para>Set the execute bit on those files only that are actually supposed 
      to get executed directly.</para>
    </sect1>

    <sect1 id=documentation>
      <title>Comments. Documenting Code</title>
      <sect2>
	<title>Module documention</title>
      	    <para>Always insert some lines of description of the module, containing at least the author and one line of short explanation. Remember that a lot of people might have to read and understand your code. Document as much as possible. Add example code how to use the module where possible and necessary. 
Please insert the following template at the beginning of the file:</para>
    	    	<screen>
#############################################################################
# ModuleName - one line explanation             
# verbose documentation, example code
# @author: author name                                                       
# @copyright: author                                                            
# @license: GPL (details at http://www.gnu.org)                                 
# @dependencies: any libs / program versions the module might depend on       
#                                                                               
# @TODO:        
#############################################################################
    	</screen>
    	<para>
	A changelog will be appended automatically to every file using comments supplied
	when commiting changes to the CVS.
    	</para>
      </sect2>

      <sect2>
	<title>Docstring documention</title>
      <para>Try to always insert at least one line of docstring 
unless the function is no more than a couple of lines long and perfectly 
self-explanatory.</para>
      </sect2>

      <sect2>
	<title>COMMENTS</title>
	<para>Mark places that need fixing with a comment like this:
	  <screen>
# FIXME: a comment on what should be fixed how
... your code ...</screen>
	</para>
      </sect2>
    </sect1>

    <sect1 id=debugging>
        <title>Debugging/Logging</title>
    	<para>Place markers before/after logging statements that can be commented out
	 once things work like this:
<screen>
#&lt;DEBUG&gt;
gmLog.Log(gmLog.lData, "this is a completely useless and wasteful, excessive log message")
#&lt;/DEBUG&gt;
</screen>
    </sect1>

    <sect1 id=SQL>
        <title>SQL hacking guidelines</title>
    	<para>When you modify the SQL scripts which create backend tables please
         follow these rules:</para>

    		<itemizedlist mark=opencircle>
				<listitem><para>don't use "\copy from stdin"
  					(reason: will kill server installation tools)
                </para></listitem>

				<listitem><para>don't use "COPY from 'a file' unless importing 
                really large datasets - and those should be imported entirely
  				separate from the schema definition import (reason: won't work 
                non-local to the DB server)
                </para></listitem>

				<listitem><para>always include gmSchemaRevision.sql in your schema
  				definition files (see the file for instructions)</para></listitem>

				<listitem><para>normalize</para></listitem>

				<listitem><para>keep things generic</para></listitem>

				<listitem><para>split things into general and country-specific parts
                </para></listitem>
			</itemizedlist>
            <para>
            Each GnuMed database has a table "gm_schema_revision". Doing a
			<ProgramListing>
            select * from gm_schema_revision
            </ProgramListing>
			will show you which version of which SQL file was imported
			into this database (as long as they adhere to the GnuMed
			SQL hacking guidelines).
			</para>
    </sect1>

    <sect1 id=configuration>
        <title>Gnumed Configuration</title>
    	<para>
	Gnumed uses two sources of configuration information:
	   - INI-style configuration files
	   - database tables
	After importing <link linkend=gmCfg>gmCfg.py</link> data stored in a standard configuration file at ~/.gnumed/gnumed.conf
	is available. Information in this file is particularly important for all activity until a connection to the backend has 
	been established. Once the backend available, configuration information stored in tables of the gnumed database can be used.
	However, it is possible to force file or database access at any time. 
    	</para>
	<sect2>
	<title>Standard configuration file</title>
    	<para>
	Currently the default configuration file holds the following information:
	<screen>
# GnuMed client config file                                                     
                                                                                
[backend]                                                                       
databases = $databases$                                                         
gnumed                                                                          
$databases$                                                                     
ports = $ports$                                                                 
5432                                                                            
$ports$                                                                         
hosts = $hosts$                                                                 
localhost                                                                       
127.0.0.1                                                                       
$hosts$                                                                         
options = $options$                                                             
                                                                                
$options$                                                                       
logins = $logins$                                                               
hinnef                                                                          
guest                                                                           
$logins$                                                                        

[workplace]                                                                     
# this is to identify the machine at a logical (business) level                 
name = test                           
	</screen>
	</para>

	</sect2>

    	<sect2>
	<title>Database configuration tables</title>
    	<para>
    	Table 'db' holds the information on databases known to gnumed. The database that has id=0 is always the default database,
	that is the database used to log in to the backend at the start of gnumed (=the one the configuration tables are stored on).
	If no entry for id=0 is present, the parameters passed on startup are used. Additional databases like demographic databases,
	drug databases must therefore use id's >= 1.
	</para>
	<para><screen>
CREATE TABLE db (
id SERIAL PRIMARY KEY,
name CHAR(35),	    	-- name of the database
port INT DEFAULT 5432,  -- port number of server hosting this database
host VARCHAR(255)DEFAULT 'localhost', -- host name of IP number of the server hosting the database
opt varchar(255) DEFAULT '',	-- options passed to the database backend
tty varchar(255) DEFAULT ''
);
	</screen>
	</para>

    	<para>
    	Table 'ddb' holds the names assigned to services known to gnumed. Names and actual databases are linked via the table 
	<link linkend=table-config>'config'</link>
	</para>
	<para><screen>
CREATE TABLE distributed_db (
	id SERIAL PRIMARY KEY,
	name char(35)
);
    	</screen>
	</para>
	
	<para>
	The following services are predefined. Naming of additional services needs approval by gnumed administrators!
    	<itemizedlist mark=opencircle>
	<listitem><para>	
    	'default' : this service contains at least the basic gnumed configuration
    	</para></listitem>

	<listitem><para>	
    	'transactions' : this service may be used for external audit trails and replication issues
    	</para></listitem>

	<listitem><para>	
    	'personalia' : this service contains all persoon and address related tables
    	</para></listitem>

	<listitem><para>	
    	'historica' : this service contains patient's medical histories
    	</para></listitem>

	<listitem><para>	
    	'extresults' : this service stores external downloadable results such as pathology
    	</para></listitem>

	<listitem><para>	
    	'correspondence' -- this service contains all correspondence (letters, emails)
    	</para></listitem>

	<listitem><para>	
    	'pharmaceutica' : this service provides all pharmaceutical information
    	</para></listitem>

	<listitem><para>	
    	'reference' : this service provides "external" reead only information such as coding (ICD) and patient
	 education material
    	</para></listitem>

	<listitem><para>	
    	'blobs' : this service takes care of large (>= 2MB )binary objects
    	</para></listitem>

	<listitem><para>	
    	'accounting'-- this services provides all tables for accounting purposes
    	</para></listitem>

	<listitem><para>	
    	'office' : this servicecontains office related tables such as rosters and waiting room
    	</para></listitem>

	<listitem><para>	
    	'modules' : this service allows to manage gnumed client modules
    	</para></listitem>
	</itemizedlist>
	</para>
	
	<para id=table-config>
	Table 'config' holds general information about available databases, services and users. 
	</para>
	<para>
	<screen>
    CREATE TABLE config (
    id SERIAL PRIMARY KEY,
    profile CHAR(25) DEFAULT 'default',     	    -- allows multiple profiles per user / pseudo user
    	    	    	    	    	    	    -- one user may have different configuration profiles depending on role, need and location
    username CHAR(25) DEFAULT CURRENT_USER, 	    -- user name as used within the gnumed system
    ddb INT REFERENCES distributed_db DEFAULT NULL, -- reference to one of the allowed distrbuted servers
    db INT REFERENCES db,   	    	    	    -- reference to the implementation details of the distributed server
    crypt_pwd varchar(255) DEFAULT NULL,    	    -- password for user and database, encrypted
    crypt_algo varchar(255) DEFAULT NULL,   	    -- encryption algorithm used for password encryption
    pwd_hash varchar(255) DEFAULT NULL,     	    -- hash of the unencrypted password
    hash_algo varchar(255) DEFAULT NULL     	    -- algorithm used for password hashing
);
    	</screen>
	</para>
    	</sect2>
	
	<sect2>	 
	<title>Setting up a service</title>
	<procedure>
	    <step><para>
	    Store the parameters to access the database in table 'db':</para>
	    <para>
<screen>
insert into db VALUES (&lt;db_id&gt;,'database_name', &lt;port&gt; , &lt;host&gt; , &lt;opt&gt; , &lt;tty&gt;);
</screen>
	    </para>
	    <para>
	    where &lt;db_id&gt; is not 0 (0 is already assigned to the default database). The parameters 
	    &lt;port&gt; , &lt;host&gt; , &lt;opt&gt; and &lt;tty&gt; can be omitted if the 
	    backend is the same as for the default database.
	    </para></step>
	    
	    <step><para>
	    Link database to service in table 'config':</para>
	    <para>
<screen>
insert into config VALUES ('','','username', &lt;distributed_db_id&gt; , &lt;db_id&gt;) ;
</screen>
	    </para>
	    <para>
	    where &lt;distributed_db_id&gt; and  &lt; db_id &gt; reference entries  in tables 'db' and 'ddb'.
	    If you add a new service, you will have to update table 'ddb' before. Please contact the gnumed admins before
	    adding new services !
	    </para></step>
	</procedure>
	</sect2>
    </sect1>
    
    <sect1 id=I18N>
      <title>Client Internationalization / Localization</title>

	<para>
	Supplied by Karsten Hilbert, &lt;Karsten.Hilbert@gmx.net&gt; GnuMed i18n/L10n coordinator
	</para>
	<para>
	At this point in time GnuMed is only prepared for being translated
	into foreign languages. This also only holds true for languages
	that can be written left-to-right with "latin" characters. Very
	little has been done to make GnuMed compatible with other aspects
	of localization such as date/time/monetary/magnitude formatting
	or icon meaning.
	</para>

	<sect2>
	<title>date/time localization</title>
	<para>
	In gmI18N.py there's a string called gmTimeFormat which holds
	the standard way of formatting a date as a string. The string
	itself is marked for translation by gettext. Translators should
	provide a translation that displays the parts of the date in
	the order and with filling characters appropriate for their
	language. This way gmTimeFormat can serve as a crude tool
	for date/time display localization. Whenever programmers want
	to display a complete date they should use gmTimeFormat as
	the formatting string instead of hardcoding their own idea
	of how a date should be displayed.
	</para>
	</sect2>
	<sect2>
	<title>icon localization</title>
	<para>
	Icon image data for plugins is located in the corresponding
	plugin source file. The icon a user wants to load is referenced
	by a string which acts as a key into the directory for the
	icon data. If no key is given to the GetIconData() method
	a hardcoded default key is used. This default key shall be
	wrapped in _() to facilitate using an appropriate default
	key per language. The key name should be of the form
	"icon_XXXX_YYYY" where XXXX_YYYY give some indication of
	the image shown on the icon (like ALT tags in HTML image
	descriptions). This key will then show up in per-language
	message catalogs and can be translated to suitable per-language
	keys. The translation must, of course, name another existing
	key/icon pair. If no translation is provided the gettext
	system will fall back to the english key and thus load
	the default icon.
	</para>
	</sect2>

	<sect2>
	<title>How to translate the GnuMed UI</title>
	<para>
	Those are the rough steps to get GnuMed translated
	into your language:

	- create a *.po file containing all English
	  message strings
	- merge this file with preexisting translations
	  for your language
	- translate the remaining non-translated English
	  program strings into your language
	- compile a binary message catalog (*.mo file) from
	  the translated messages
	</para>
	</sect2>

	<sect2>
	<title>Creating a *.po file</title>
	<para>
	With
<screen>
 &lt;create-gnumed_po.sh $LANG&gt;
</screen>
	you can rescan the Python source for strings that need
	translation. The result is merged with the file $LANG.po
	which serves as a repository of previously translated
	strings. You can then edit this file adding in more
	translations for message strings. For this you can use
	a simple text editor or any tool you wish (such as EMACS
	po mode or kbabel) as long as you keep a copy of your
	final results in $LANG.po as a repository for future
	translations.

	If you execute this script for the first time you will
	end up with a $LANG.po file without any previous translations.
	In this case you need to edit a few metadata entries at the
	very top of the $LANG.po file such as the character set you
	are using.

	Hints for translations:
	 - look at translations in other languages to get an idea
	 - look at the source and/or the running GnuMed to find good translations
	 - keep exactly the same number of %s, %d etc in your translation,
	   they are formatting placeholders and will be replaced with
	   certain data (such as file names) dynamically at runtime
	 - if the file asks you to translate the empty string ("")
	   go into the python source and remove the _() around the
	   empty string,
	   the empty string cannot be translated and _will_ produce errors
	   because it is used as the message string ID for po-file
	   metadata
	</para>
	</sect2>

	<sect2>
	<title>Creating a *.mo file</title>
	<para>
	With 
<screen>
 &lt;create-gnumed_mo.sh $LANG&gt;
</screen>
	you can compile a *.mo file from the message catalog source.
	You will end up with a $LANG-gnumed.mo file.
	</para>
	</sect2>

	<sect2>
	<title>Installation of translated messages</title>
	<para>
	On a POSIX system (Linux, BSD, MacOSX, CygWin) the
	$LANG-gnumed.mo file should be moved into
	 /usr/share/locale/$LANG/LC_MESSAGES/
	or the corresponding standard place. Alternatively you
	can make symlinks from there to
	 /usr/share/gnumed/client/locale/$LANG.mo

	You need to name either the copy or the symlink "gnumed.mo".

	On MS Windows you must create the following directories:
	client/
	 client/wxpython/
	 client/locale/
	  client/locale/$LANG/
	   client/locale/$LANG/LC_MESSAGES/

	You then need to move the $LANG-gnumed.mo to the
	appropriate LC_MESSAGES directory (or make a symlink)
	again under the name of "gnumed.mo".
	</para>
	</sect2>

	<sect2>
	<title>Coding I18N</title>

	      <para>Hardcoded error strings meant for developers / debugging are in English. All other 
	      strings MUST be translateable, that is called as a gettext function. To achieve this, 
	      you do the following:
	      </para>
	      <para>
	      If your modules can be called as a standalone script you should add this to your main part:
<screen>
if name == '__main__':
	import gettext
	_ = gettext.gettext()
    # ... now on to other stuff
</screen>

	      If your module is invoked from within the GNUmed framework the translation function _() is 
	      automatically defined for you.
	      </para>
	      <para>
	      Now, whenever you use a string, do it like
<screen>
print _("this will be automatically translated")
instead of
print "this can't be translated and should thus not be written this way"
</screen>
	      </para>

		  <para>
           Note:"&" often refers to menu item shortcuts.You should keep those
           but make them unique to the menu in your target language.
          </para>

	<sect2>
	<title>GUI text localization</title>
	<para>
	The GNU gettext system is used to provide a user interface
	translated into the local language. Currently only the
	original English version and a German translation exist.

	NOTE: $LANG corresponds to the ISO code for your language
	NOTE: Requires gettext tools to be installed.

	Message catalogs, related files and useful shell scripts
	live in the directories below gnumed/client/locale/ .
	</para>
	</sect2>
    </sect1>



	<sect2>
    	<title>How to make the frontend use translated strings</title>
		<para>
        All the backend infrastructure is in place now so we
        can make frontends aware of translated strings. The first
        step is to make frontends use the v_i18n_* views instead
        of the tables. If we fail to do that everything will still
        work. We just won't get translations :-)
		</para>
        <para>		
        The second step is to make sure the current user has
        a language selected in i18n_curr_lang. Use something like
		</para>
        <screen>
insert into i18n_curr_lang(lang) values ('de_DE');
		</screen>
        <para>
        This will default to the CURRENT_USER. The actual value need
        not conform to anything in particular. It can be "Klingon" for
        that matter. Make sure then to have "Klingon" translations
        available in i18n_translations.
		</para>

	    <para>
	    This i18n technique does not take care of strings that are inserted
        into the database dynamically (at runtime). It only makes sense for
	    strings that are inserted once. Such strings are often used for
	    enumerations.
	    </para>
        <para>
	    All this crap isn't necessary anymore once PostgreSQL supports
	    native internationalization of 'fixed' strings.
	    </para>
	</sect2>
	</sect1>
        
    	<sect1 id=backend-interaction>
    	    <title>Interacting with the Backend</title>
	    <para>
	    Supplied by Horst Herb
	    </para>
	    <para>
	    Most of the backend interaction happens through <ulink url="http://www.python.org/topics/database/DatabaseAPI-2.0.html">
	    <citetitle>DB-API 2.0</citetitle></ulink> compliant database adapters. Since there are still a few ambiguities
	    in the API definition, and furthermore some important PostgreSQL specific
	    features not accessible via DB-API, we have decided to focus mainly on one
	    specific adaper: <ulink url="http://pypgsql.sourceforge.net/"><citetitle>PyPgSQL</citetitle></ulink>. This
	    should not be a problem, since it is highly portable. We have succesfully
	    compiled it so far on different flavours of Linux and BSD, on different versions
	    of Windows, and on Mac OS/X.
	    </para>
	    <para>
	    In order to understand how to access the backend in principle, you'll have
	    to understand the <ulink url="http://www.python.org/topics/database/DatabaseAPI-2.0.html"><citetitle>
	    DB-API specifications</citetitle></ulink> first. You can find a brief generic introduction
	    <ulink url="http://www.amk.ca/python/writing/DB-API.html"><citetitle>here</citetitle></ulink>.
	    </para>
	    <para>
	    Next, you'll have to understand the concept of "<link linkend=services>
	    services</link>" in GnuMed. Fortunately, most of the complexity behind services
	    is handled by the service broker object <link linkend=gmPG>
	    gmPG</link>. gmPG will also handle a lot of other complex issues such as gathering
	    log in information in order to make backend connections in the first place.
	    </para>
	    <para>
	    PostgreSQL is fully transactional. Transactions (sequences of database modifications)
	    are only "committed" if the server is told so, otherwise the transactions
	    are rolled back (changes will not be visible in the database). Rollbacks
	    happen automatically if an error occurs during a transaction that may affect
	    the integrity of the database, but the rollback can also be initiated programmatically.&nbsp;
	    PostgreSQL "commits" happen on connection level. If a connection has several
	    active cursors (which it may at any time), a "commit" will affect all of
	    these cursors.
	    </para>
	    <para>
	    Thus, in order not to interfere accidentally with other transactions, any
	    client action that modifies the backend database MUST request a separate
	    connection. However, establishing a connection is ressource intensive and
	    costs time, even if it is only milliseconds on a LAN. Since most of the database
	    interaction is typically read-only, where we don't have to fear transactional
	    collisions, we don't need to establish extra costly connections for the client
	    objecst that just want to read the database without modifying it.
	    </para>
	    <para>
	    Since we want to make gnumed as resistant to programmatic errors as reasonably
	    possible, we have decided to make sure that write access will not happen
	    accidentally through a "read-only" connection. Unfortunately,PostgreSQL provides
	    no simple way of achieving this. Our current solution is that a pseudo-user
	    is created for each user; the user gets only read-only access, the pseudo-user
	    gets res &amp; write access. Once again, this is handled entirely transparent
	    by <link linkend=gmPG>
	    gmPG</link>. If a read-only connection is requested, gmPG will return an open
	    connection from a pool of shared connections. If a writeable connection is
	    requested, gmPG opens a new connection under the alias of the pseudo-user
	    associated with the current user.
	    </para>
	    <para>
	    For a practical example, let us assume we want to access a person's demographic
	    details. From the "<link linkend=services>services table</link>" we know
	    that this information is available through the service "personalia". Our
	    request for a read-only connection would look like this:
	    </para>
	    <para>
<screen>
import gmPG
connection = gmPG.ConnectionPool().GetConnection("personalia")
</screen>
	    </para>
	    <para>
	    That's all! If we are already logged in, gmPG will use the cached login information.
	    If not, gmPG will determine whether we are using a graphical user interface
	    and display a nice login dialogue, otherwise it will ask for login parameters
	    via command line. Then, gmPG will determine in which physical database the
	    service "personalia" is located, and return that connection.
	    </para>
	    <para>
	    Now, we could already start doing something with the database. We could for
	    example get a list of all people who's surname begins with "H":
	    </para>
	    <para>
<screen>
cursor = connection.cursor()
cursor.execute("Select * from v_basic_person where name like 'H%'" )
result = cursor.fetchall()
</screen>
	    </para>
	    <para>
	    "result" will contain a list of "PgResultSet" objects, if there are any database
	    rows matching the search criteria. The PgResultSet is a most convenient object
	    wrapper which among other things allows us to address attributes by their
	    names:
	    </para>
	    <para>
<screen>
    for person in result:
	print person['title'], person['firstnames'], person['lastnames'], person['dob']
</screen>
	    </para>
	    <para>
	    Of course, in most cases you would not query the database directly like that.
	    You would rather access the backend via classes derived from <link linkend=gmDbObject>
	    gmDbObject</link> or at a even higher level through one of the cached database
	    objects.
	    </para>
    	</sect1>


    	<sect1 id=internal-messaging>
	    <title>Internal Messenging and Signal Dispatching</title>
	    <para>
	    Supplied by: Horst Herb
	    </para>

	    <para>The gnumed client depends on two different types 
	    of messages:</para>

	    <orderedlist numeration="arabic">
		<listitem><para>Messages coming form the backend. Example: a receptionist queues 
	     patients as they arrive into a waiting room widget. On the doctors screen 
	     there should be a small widget informing him about the number of patients 
	     waiting for him. This is achieved through asynchronous messages from the backend.</para></listitem>
		<listitem><para>Client-internal messages. They allow widgets to communicate. Example: 
	     One widget allows the doctor to select the active patient. This widget, after 
	     selection, has to notify other widgets depending on this information (like 
	     widgets displaying the patients past medical history, his allergies etc.) 
	      to update themselves.</para></listitem>

	    </orderedlist><para>
	     Both types of messages are handled via a global dispatcher module called 
	    <link linkend=gmDispatcher> gmDispatcher.py </link>
	     The module <link linkend=gmPG>gmPG.py </link>
    	    takes care of handling the asynchronous messages from the backend 
	    via a separate background thread.</para><para>
	     </para><para>
	     Procedure changing "global" data that may affect any other widget, must
	    post a message through gmDispatcher.</para><para>
	     </para><para>
	     Widgets depending on backend data must register their interest through gmDispatcher.</para><para>
	     </para><para>
	     A  table listing all available message labels
	      ("signals") and their meanings can be found <link linkend=signals>here.</link>
	      However, these message strings should never be hardcoded. Developers must 
	    instead use the embedding variables as listed in the module <link linkend=gmSignals>gmSignals.py </link>.</para><para>
	     </para><para>
	     Developers writing code that creates new signals must
	     update this webpage via CVS.</para><para>
	     </para><para>

	    <emphasis>Examples:</emphasis>

	    <orderedlist numeration="arabic">
	    	<listitem><para>A widget allows to select the current patient.
	     	    <orderedlist numeration="arabic">
		    <listitem><para>It first registers it's interest in all patients added, modified
		    or deleted with the backend as it should always be able to display the most
		    current status of the backend data. For that purpose, it defines a callback
		    function "self.OnDemographicsUpdated()".</para></listitem>
    		    
		    <listitem><para>Then, it registers this callback function with the dispatcher for
		    all signals that would modify the patient database.  </para><para>
		    If anybody within a gnumed system modifies demographic information, this
		    widget would be automatically notified about this.  </para><para>
		    </para></listitem>
		    
		    <listitem><para>Once the user has interactively selected a patient, it has to alert
		    all other widgets that this has happened. For that purpose, the event handler
		    reacting to a patient being selected notifies the gmDispatcher about this. 
		    </para><para>
    	    	    	<screen>
     def __init__(self):

         #register our interest in the&nbsp;patients stored on the backend

         gmDispatcher.connect(self.OnDemographicsUpdated, gmSignals.demographics_updated())

        	     	</screen>
    	    	    	<screen>        	     
    def OnDemographicsUpdated(self, id):
	"when the patients have changed on the backed, update the ones we display"

        #id is irrelevant here; we just update the whole displayed list

        self.UpdatePatientList()
        	        </screen>
        	     
    	    	    	<screen>        	     
    def UpdatePatientList(self):
	"Update the displayed list of patients from the backend"

      #request a backend connection

      db = gmPG.ConnectionPool().GetConnection('demographica')

      cursor = db.cursor()

      #query patients to be displayed

      cursor.execute(....)

      result = cursor.fetchall()

      #display the result
    	    	    	</screen>
        		  
        	       
        	     	<screen>
     def OnPatientSelected(self, id):
	 """When a patient has been selected by the user, call this function     
	 id is the primary key identifying the selected patient"""     

    	 gmDispatcher.send(gmSignals.patient_selected(), id=id)
    	    	    	</screen>    	       
        	     
		 </para></listitem>

	      </orderedlist>
	      </para></listitem>
	      <listitem><para>Another widget displays the current (active) patient's name.&nbsp;

	      <itemizedlist mark=closedcircle>

		<listitem><para>Thus, it has to register it's interest in the event the current patient
	    changes. The registered callback could query the database directly. However,
	    data that is likely to be shared among many widgets, should be cached to
	    avoid unneccessary backend traffic and to improve client performance. Thus,
	    it requests the data from the gmCachedPerson.CachedPerson object:
      <screen>
      def __init__(self):
        #code to display and place the widget
        # now register our callback function with the dispatcher
        gmDispatcher.connect(self.Update, gmSignals.patient_selected())
      </screen>

      <screen>
      def Update(self, id_patient):
        "show the currently selected patient"
        patient = gmCachedPerson.CachedPerson.dictresult()
        self.TxtctrlSurname.SetValue(patient['surname']
        ....
      </screen>
		</para></listitem>
	      </itemizedlist>
    	      </para></listitem>
	    </orderedlist>

    	</sect1>


    <sect1 id=widgets>
      <title>Widgets</title>
      <para>When trying to map database results to widgets, remember that not all 
widgets can use the same functions (like SetValue()) under all 
circumstances to set their properties. Notable examples for exceptions are 
"choice boxes" and "combo boxes". It might be preferrable to have a 
function SetData(), UpdateData(), ClearData() for each dialog instead - 
far more control over what is actually happening to the widgets, though 
unfortunately a little bit more typing.</para>

    </sect1>
    </chapter>

    <chapter id=modules>
    	<title> Modules </title>
<sect1 id=python-common><title>python-common</title>

<sect2 id=gmCfg><title>gmCfg.py</title>
<screen>
GNUmed configuration handling.

Two sources of configuration information are supported:

 - INI-style configuration files
 - database tables

Just import this module to have access to a default config file.

Theory of operation:

Upon importing this module a basic config file will be parsed. This
file is registered at the default source for configuration information.

The module will look for the config file in the following standard
places:

1) programmer supplied arguments
2) user supplied command line (getopt style):	--conf-file=&lt;a file name&gt;
4) ~/.&lt;aDir&gt;/&lt;aName&gt;.conf
5) ~/.&lt;aName&gt;.conf
6) /etc/&lt;aDir&gt;/&lt;aName&gt;.conf
7) /etc/&lt;aName&gt;.conf
8) ./&lt;aName&gt;.conf		- last resort for DOS/Win

&lt;aDir&gt; and &lt;aName&gt; will be derived automatically from the name of
the main script.

It is helpful to have a solid log target set up before importing this
module in your code. This way you will be able to see even those log
messages generated during module import.

Once your software has established database connectivity it can call
 activateDatabase()
to switch on database access for configuration options.

The default config data source is then switched to database access.

At any time can you force file or database access for a particular
configuration call via a parameter except before database access is
activated in which case the module will always use file access.

NOTE: DATABASE CONFIG DOES NOT WORK YET !

class cCfgBase:
	def __init__(self):
		pass

	def get(machine = None, user = None, cookie = None, option = None):
		pass

	def set(machine = None, user = None, cookie = None, option = None, value = None):
		pass

class cCfgFile:
    	Handle common INI-style config files.

	The INI file structure follows the common rules. Option values
	can be strings or lists of strings. Lists are handled transparently.
	The list format is as follows:

	listname = $listname$ # comment
	item 1
	item 2
	item 3
	$listname$

	Config data is cached in the following layout:

	self._cfg_data	= {dict}
	|
	|-> 'comment'	= [list of strings]
	`-> 'groups'	= {dict}
	 |
	 |-> group 1	= {dict}
	 | ...
	 `-> group n
	  |
	  |-> 'comment' = [list of strings]
	  `-> 'options'	= {dict}
	   |
	   |-> option 1	= {dict}
	   | ...
	   `-> option n
	    |
		|-> 'comment' [list of strings]
		`-> 'value'

	def __init__(self, aPath = None, aFile = None):

	def getCfg(self):
		Return handle to entire config dict.

	def get(self, aGroup = None, anOption = None):

	def getComment(self, aGroup = None, anOption = None):

	def set(self, aGroup = None, anOption = None, aValue = None, aComment = None):
		Set an option to an arbitrary type.
		This does not write the changed configuration to a file !

	def store(self):
		Store changed configuration in config file.
		# FIXME: actually we need to reread the config file here before writing
</screen></sect2>

<sect2><title>gmCachedAddress.py</title><screen>

 gmCachedAddress - data broker for a person's address
 @TODO: Almost everything

 class AddressCache(gmDBCache.DBcache)
 class CachedAddress(gmDBCache.CachedDBObject)
	def get(self, id=None, by_reference=0, refresh_only=0):
	def create_address_link( self, addressMap, db):
	def update_address_link(self, addressMap, db):
	def dictresult(self, id=None):
</screen></sect2>

<sect2><title>gmCachedDBObject.py</title>
<screen>
# gmCachedDBObject : abstraction and performance improvement for simple
#                     database query result objects
#
#
# CachedDBObject is a base class which should not
# be used directly.
# In order to derive a functional class from CachedDBObject, do as follows:
#
# class Derived(CachedDBObject):
#
#       #first, create the "shared buffer" variable
#	dbcache = DBcache()
#       #this static variable MUST have the name "dbcache"
#       #it must create an instance of DBcache or a subclass thereof
#
#       #then, create the appropriate constructor
#	def __init__(...)
#		#now create a reference to the static variable
#		self.cache = Derived.dbcache
#		#and pass it to the constructor
#		cachedDBObject.__init__( cache=self.cache...)
#               #__init__ MUST call the base class constructor
#
# When creating more than one instance from "Derived",
# the callback system should be used to ensure that any
# instance using the shared buffer gets notified of buffer changes:
#
# myInstance = Derived(...)
# myInstance.notify_me('identifier of myInstance', callback_function)
#
# where 'identifier of myInstance' is an arbitrary string and
# 'callback function' is a function of the prototype:
#
# function('identifier of callback triggering class', 'id')
#
# where 'id' typically would be the foreign key causing the
# current data set in the buffer
#

class DBcache:
	"prototype for a database object cache 'static' (singleton) information"

class CachedDBObject

	def reset(self)
		"force a re-query of buffer on next data access attempt"

	def setQueryStr(self, querystr)

	def getQueryStr(self)

	def setId(self, id, lazy=0)

	def getId(self)
		"get the ID of the current object"

	def get(self, id=None, by_reference=0, refresh_only=0):
		returns the buffer. If id is not None and not in cache,
		the backend will be queried.
		If by_reference is not zero, a copy of the buffer instead 
		of a reference to it will be returned.
		When using multiple threads to access the data,
		always use copies of the buffer!

	def notify_me(self, who, callback=None):
    		Register function 'callback' for caller 'who'

		If callback is None, the callback for caller 'who'
		will be removed (if exists)
		'callback' is a function that accepts two parameters:
		The first parameter is the identity of the registered
		caller ('who'), the second parameter is the buffer id.
		'callback' must not return anything

	def queue_notification(self, queue=1):
		simple helper mechanism to ensure only the most recent thread
		updates widgets on data change
		
	def notify(self):
		forces execution of all registered callback functions
		This function will be called whenever the buffer changes
		
	def attributes(self):
		returns row attributes ('field names')

	def pprint(self):
		"format buffer content in printable form"

	def dictresult(self):

</screen>
</sect2>
<sect2 id=gmDispatcher><title>gmDispatcher.py</title><screen>

     Provides global signal dispatching services.

class DispatcherError(exceptions.Exception)

class _Any:
    	# Helper class
	
Methods provided by gmDispatcher:

     def connect(receiver, signal=Any, sender=Any, weak=1)
	Connect receiver to sender for signal

	If sender is Any, receiver will receive signal from any sender.
	If signal is Any, receiver will receive any signal from sender.
	If sender is None, receiver will receive signal from anonymous.
	If signal is Any and sender is None, receiver will receive any 
	    signal from anonymous.
	If signal is Any and sender is Any, receiver will receive any 
	    signal from any sender.
	If weak is true, weak references will be used.

     def disconnect(receiver, signal=Any, sender=Any, weak=1)
	Disconnect receiver from sender for signal.

	Disconnecting is not required. The use of disconnect is the same as for
	connect, only in reverse. Think of it as undoing a previous connection.

     def disconnect(receiver, signal=Any, sender=Any, weak=1)
	Disconnect receiver from sender for signal.

	Disconnecting is not required. The use of disconnect is the same as for
	connect, only in reverse. Think of it as undoing a previous connection.

     def send(signal, sender=None, **kwds)
	Send signal from sender to all connected receivers.

	Return a list of tuple pairs [(receiver, response), ... ].
	If sender is None, signal is sent anonymously.

     def _call(receiver, **kwds)
	Call receiver with only arguments it can accept.

     def safeRef(object)
	Return a *safe* weak reference to a callable object.

class BoundMethodWeakref

    def __init__(self, boundMethod):
        Return a weak-reference-like instance for a bound method.

    def __repr__(self)
        Return the closest representation.

    def __call__(self)
        Return a strong reference to the bound method.

    def _removeReceiver(receiver)
    	Remove receiver from connections.

    def _cleanupConnections(senderkey, signal)
        Delete any empty signals for senderkey. Delete senderkey if empty.

    def _removeSender(senderkey)
    	Remove senderkey from connections.

</screen></sect2>
<sect2><title>gmExceptions.py</title><screen>
class ConnectionError(Exception)
	#raised whenever the database backend connection fails

class ConfigError(Exception)
	#raised whenever a configuration error occurs

class NoGuiError(Exception):
	#raised whenever the database backend connection fails

class PureVirtualFunction(Exception):
	#raised whenever the database

</screen></sect2>
<sect2><title>gmGuiBroker.py</title><screen>
GNUMed GUI element brokerage

This module provides wrappers for the equivalent of global
variables needed for a gnumed GUI client interface

class GuiBroker:
	Wrapper for global objects needed by GNUMmed GUI clients

	#This class wraps all global gui objects (variables)for a gnumed
	#application. The static (at application level)dictionary
	#__objects can be accessed through the method addobject
	#and getobject.
	#So, if you need to access the main window frame, you would
	#query an instance of GuiBroker for it.

	def addobject(self, widget, key=None):
		Add an object to the gnumed gui object dictionary"

		An object can be anything (class, variable, widget)
		The "key" is a key expression (number, text) that
		allows you to retrieve the object.
		Convention for keys is the widget or variable name
		as a text string
		If key is not passed as parameter, a unique serial
		number is allocated as key and returned

	def getobject(self, key):
		allows to retrieve a gnumed gui element; see addobject()
		regarding the key parameter

	def keylist(self):
		returns a list of all keys; see documentation for the
		dictionary data type

	def valuelist(self):
		returns a list of all values; see documentation for the
		dictionary data type

	def itemlist(self):
		returns a list of all key:value pairs;
		see documentation for the dictionary data type

	def __getitem__(self, key):
		Allows retrieving the value via value = instance[key]

	def __setitem__(self, key, object):
		Allows access in the style of instance[key]=value

</screen></sect2>
<sect2><title>gmI18N.py</title><screen>
GNUmed client internationalization/localization.

All i18n/l10n issues should be handled through this modules.

Theory of operation:

By importing this module a textdomain providing translations is
automatically installed. The translating method gettext.gettext()
is installed into the global (!) namespace as _(). Your own modules thus
need not do _anything_ (not even import gmI18N) to have _() available
to them for translating strings. You need to make sure, however, that
gmI18N is imported in your main module before any of the modules using
it. In order to resolve circular references involving modules that
absolutely _have_ to be imported before this module you can explicitely
import gmI18N into them at the very beginning.

The text domain (i.e. the name of the message catalog file) is derived
from the name of the main executing script unless explicitely given on
the command line like this:
 --text-domain=&lt your text domain &gt

This module searches for message catalog files in 3 main locations:
 - in standard POSIX places (/usr/share/locale/ ...)
 - below (one level above binary directory)/locale/

For DOS/Windows I don't know of standard places so only the last
option will work unless you have CygWin installed. I don't know a
thing about classic Mac behaviour. New Mac's are POSIX, of course.

The language you want to see is derived from the following locale
related environment variables (in this order):
 - LANGUAGE
 - LC_ALL
 - LC_MESSAGES
 - LANG

</screen></sect2>
<sect2><title>gmLog.py</title><screen>

GNUMed client log handling.

All error logging, user notification and otherwise unhandled 
exception handling should go through classes or functions of 
this module

Theory of operation:

A logger object is a unifying wrapper for an arbitrary number
of log targets. A log target may be a file, syslog, the console,
or an email address, or, in fact, any object derived from the
class cLogTarget. Log targets will only log messages with at least
their own message priority level (log level). Each log target
may have it's own log level.

There's also a dummy log target that just drops messages to the floor.

By importing gmLog into your code you'll immediately have
access to a default logger: gmDefLog. Initially, the logger has
a log file as it's default target. The name of the file is
automatically derived from the name of the main application.
The log file will be found in one of the following standard
locations:

1) given on the command line as "--log-file=&lt log file &gt"
2) ~/.&lt base_name &gt/&lt base_name &gt .log
3) /var/log/&lt base_name &gt/&lt base_name &gt .log
4) /var/log/&lt base_name &gt .log
5) /dir/of/binary/&lt base_name &gt .log	- mainly for DOS/Windows

where &lt base_name &gt is derived from the name
of the main application.

By importing gmLog and logging to the default log your modules
never need to worry about the real message destination or whether
at any given time there's a valid logger available. Your MAIN
module simply adds real log targets to the default logger and
all other modules will merrily and automagically start logging
there.

You can of course instantiate any number of additional loggers
that log to different targets alltogether if you want to keep
some messages separate from others.

Usage:
1.) if desired create an instance of cLogger
2.) create appropriate log targets and add them to the default logger or your 
    own (from step 1)
3.) call the cLogger.LogXXX() functions

# log levels:
# lPanic - try to log this before we die
# lErr   - some error occured, may be recoverable
# lWarn  - something should be done about this though it's not fatal
# lInfo  - user info like program flow
# lData  - raw data processed by program

# injudicious use of lData may lead to copious amounts of log output
# and has inherent security risks (may dump raw data including passwords,
# sensitive records, etc)


class cLogger:
	def __init__(self, aTarget=None):
		Open an instance of cLogger and initialize a target.
		in case there's no target given open a dummy target

	def close(self):
		Close this logger and cleanly shutdown any open targets.

	def AddTarget (self, aTarget):
		Add another log target.

		- targets must be objects derived from cLogTarget
		- ignores identical targets
		- the number of concurrent targets is potentially unlimited

	def RemoveTarget (self, anID):
		Remove a log target by it's ID.
		- clients have to track target ID's themselves if they want to
		  remove targets

	def Log(self, aLogLevel, aMsg, aRawnessFlag = lUncooked):
		Log a message.

		- for a list of log levels see top of file
		- messages above the currently active level of logging/verbosity
		  are dropped silently
		- if Rawness == lCooked non-printables < 32 (space) will be mapped to
		  their name in ASCII
		- FIXME: this should be a Unicode mapping

	def LogDelimiter (self):
		Write a horizontal delimiter to the log target.

	def LogException(self, aMsg, exception, fatal=1):
		Log an exception.
		'exception' is a tuple as returned by sys.exc_info()

	def SetAllLogLevels (self, aLogLevel = None):
		Set a certain log level on all targets.

private classes / methods:
class cLogTarget:
	Base class for actual log target implementations.
	- derive your targets from this class
	- offers lots of generic functionality

	def __init__(self, aLogLevel = lErr)
	def close(self)
	def getID (self)
	def SetLogLevel(self, aLogLevel)
	def writeMsg (self, aLogLevel, aMsg)
	def hasLogged (self)
	def writeDelimiter (self)
	def flush (self)

</screen></sect2>
<sect2><title>gmLoginInfo.py</title><screen>
# gmLoginInfo - a class to encapsulate Postgres login information

class LoginInfo:
	"a class to encapsulate Postgres login information"

	def __init__(self, user, passwd, host='localhost', port=5432, database='gnumed', options='', tty='', profile='default'):

	def SetInfo(self, user, passwd, host='localhost', port=5432, dbname='gnumed', opt='', tty='', profile='default'):

	def GetInfo(self):

	def GetInfoStr(self):
	    # doesn't hand out passwords 

	def GetPGDB_DSN(self):
    	    return dsn in colon delimited form as one string and host
	    
	def GetDBAPI_DSN(self):
    	    return dsn in colon delimited form as one string
	  
    	def SetUser(self, user):
	def GetUser(self):
	def SetPassword(self, passwd):
	def SetPassword(self, passwd):
	def GetPasswordHash(self):
	def SetDatabase(self, dbname):
	def GetDatabase(self):
	def SetHost(self, host):
	def SetHost(self, host):
	def SetPort(self, port):
	def GetPort(self):
	def SetOptions(self, opt):
	def GetOptions(self):
	def SetTTY(self, tty):
	def GetTTY(self):
	def GetTTY(self):
	def GetTTY(self):

	def Clear(self):
		"clears all connection information regarding user, password etc."

</screen></sect2>
<sect2 id=gmPG><title>gmPG.py</title><screen>
# gmConnectionPool - Broker for Postgres distributed backend connections

as of 09.08.2002 tries to handle psycopg (Zope), PyPGSql and pgdb

class ConnectionPool:
	"maintains a static dictionary of available database connections

	def __init__(self, login=None):
		parameter login is of type gmLoginInfo.LoginInfo

	def GetConnection(self, service):
		"if a distributed service exists, return it - otherwise return the default server"

	def ReleaseConnection(self, service):
		"decrease reference counter of active connection"

	def GetAvailableServices(self):
		list all distributed services available on this system
		(according to configuration database)

	def Connected(self):

	def LogError(self, msg):
		"This function must be overridden by GUI applications"

#---------------------------------------------------
# database helper functions
#---------------------------------------------------
def cursorIndex(cursor):
	returns a dictionary of row atribute names and their row indices

def descriptionIndex(cursordescription):
	returns a dictionary of row atribute names and their row indices

def dictResult(cursor, fetched=None):
	"returns the all rows fetchable by the cursor as dictionary (attribute:value)"

def fieldNames(cursor):
	"returns the attribute names of the fetched rows in natural sequence as a list"
	
def listDatabases(service='default'):
	"list all accessible databases on the database backend of the specified service"

def listUserTables(service='default'):
	"list the tables except all system tables of the specified service"

def listSystemTables(service='default'):
	"list the system tables of the specified service"

def listSystemTables(service='default'):
	"list the system tables of the specified service"

def quickROQuery(query, service='default'):
	a quick read-only query that fetches all possible results at once
	returns the tuple containing the fetched rows and the cursor 'description' object

def getBackendName():

def prompted_input(prompt, default=None):

def inputTMLoginParams():
	text mode input request of database login parameters

def inputWXLoginParams():
	GUI (wx) mode input request of database login parameters.
	Returns gmLoginInfo.LoginInfo object

def inputLoginParams():
	"input request for database backend login parameters. Try GUI dialog if available"

</screen></sect2>
<sect2><title>gmPlugin.py</title><screen>

# gmPlugin - base classes for GNUMed's plugin architecture
class gmPlugin:
	base class for all gnumed plugins

	def provides ():
		Returns a list of services that the plugin provides

	def requires ():
		Requires a list of services that must be registered
		before this plugin is registered. The configuration
		tool must check these and make sure the load order
		satisfies the plugins' requirements

	def description ():
		Returns a brief description of the plugin.

	def name (self):

	def register(self):

	def unregister(self):

class wxBasePlugin (gmPlugin):
	
	
	base class for all plugins providing wxPython widgets.
	Plugins must have a class descending of this class in their file, which MUST HAVE THE SAME NAME AS THE FILE.
	The file must be in a directory which is loaded by LoadPluginSet (gui/ for the moment, others may be added for different plugin types)

	# NOTE: I anticipate that all plugins will in fact be derived
	# from this class. Without the brokers a plugin is useless (IH)

	def __init__(self, guibroker=None, callbackbroker=None, dbbroker=None, params=None):

	def GetIcon (self):
		Return icon representing page on the toolbar.
		This is the default behaviour. GetIconData should return
		pickled, compressed and escaped string with the icon data.

		If you want to change the behaviour (because you want to load
		plugin icons from overseas via a satellite link or something
		you need to override this function in your plugin (class).

		Using this standard code also allows us to only import cPickle
		and zlib here and not in each and every plugin module which
		should speed up plugin load time :-)

		# FIXME: load from config which plugin we want
		# which_icon is a cookie stored on the backend by a config manager,
		# it tells the plugin which icon to return data for,

	def GetIconData(self, anIconID = None):
		# FIXME: in overriding methods need to be very careful about the
		# type of the icon ID since if we read it back from the database we
		# may not know what type it was

	def GetWidget (self, parent):
		Return the widget to display

	def MenuInfo (self):
		Return tuple of (menuname, menuitem).
		menuname can be "tools", "view", "help", "file"

	def Raise (self):
		Raises this plugin to the top level if not visible.

	def Shown (self):
		Called whenever this module is shown onscreen.

class wxNotebookPlugin (wxBasePlugin):
	
	Base plugin for plugins which provide a 'big page'
	Either whole screen, or notebook if it exists
		
	def register (self):
		Register ourselves with the main notebook widget.

	def unregister (self):
		Remove ourselves.

	def Raise (self):
	def OnMenu (self, event):
	def GetNotebookNumber (self):
	def DoToolbar (self, tb, widget):
		
		sets up the toolbar for this widget.
		tb is the toolbar
		widget is the widget returned by GetWidget () for connecting events


class wxPatientPlugin (wxBasePlugin):
	
	A 'small page', sits inside the patient view, with the side visible

	def register (self)
	def OnTool (self, event):
	def Raise (self):
	def unregister (self):


def LoadPlugin (aPackage, plugin_name, guibroker = None, dbbroker = None):
	Loads a plugin from a package directory.

	- "set" specifies the subdirectory in which to find the plugin
	- this knows nothing of databases, all it does is load a named plugin

	There will be a general 'gui' directory for large GUI
	components: prescritions, etc., then several others for more
	specific types: export/import filters, crypto algorithms
	guibroker, dbbroker are broker objects provided
	defaults are the default set of plugins to be loaded

	FIXME: we should inform the user about failing plugins

def GetAllPlugins (set):
	
	Searches the directory for all plugins

def UnloadPlugin (set, name):
	
	Unloads the named plugin

</screen></sect2>

<sect2><title>gmdbf.py</title><screen>

This is a module for reading dbf files.

It has been modified thanks to suggestions and patches from Jeff Bauer
and Kevin Dahlhausen. Unfortunately I lost patches which fix
endianness problems, which were sent to me by someone, so that will
have to wait. I do not use this module much these days, but since it
seems to be in use "out there" I thought I would finally make an
update available. This version should be more portable. Also, rather
than printing an error message an exception is now raised when the dbf
file appears to be corrupt.

Usage: the following

import dbf
db = dbf.dbf('mydata.dbf')

creates a dbf object db associated with an existing dbf file
'mydata.dbf'.  The dbf file is opened by the constructor. If the file
is not there IOError is raised. If the file appears not to be a dbf
format file, TypeError is raised.

If you prefer to create a dbf object, but open the actual file later,
you can use the following:

import dbf
db = dbf.dbf('mydata.dbf', openit=0)

and then you can call

db.open()

to actually open the file. Note that the constructor, if called this
way, does not verify that the file is there, so the IOError exception
is raised by the call to open.

Once the dbf object is created and opened (implicitly or not), the
following are available:

-- db.fields  : returns a a list of tuples describing the fields
-- db.nrecs   : returns the number of records
-- db[n]      : returns a tuple containing record number n (0 <= n < nrecs)
-- db.status(): prints some essential data about the dbf file

So to list the first two fields of mydata.dbf, assuming they are string
fields, one might write:

import dbf
from string import strip
db=dbf.dbf('mydata.dbf')
for k in db:
    print "%s, %s" % (strip(k[1]), strip(k[2]))


Good luck!

class dbf:
	def __init__(self, fname, openit=1):
	def open(self):
	def _get(self, recno):
	def __getitem__(self, recno):
	def dictresult(self, recno):
	def status(self):
	def close(self):


</screen>
</sect2>

<sect2 id=gmSignals><title>gmSignals.py</title>
<screen>
# gmSignals.py

gmSignals - factory functions returning GnuMed internal signal strings. 
This helps to avoid that  simple typographic mistakes result in messages
not being dispatched. It would allow to do messenging house keeping as well.

def popup_notice():
	a notice of general interest has been received

def popup_alert():
	an important notice of general ineterest has been received
	
def patient_selected():
	the current active patient displayed by the client has been selected
	
def patient_modified():
	the current patients demographic data has been modified
	
def medication_modified():
	the current patient's medication has been modified
	
def waitingroom_added():
	a patient has been added to the waiting room
	
def waitingroom_incons():
	a patient has started his consultation with the doctor
	
def waitingroom_left():
	a aptient has left the waiting room, finished his consultation

</screen>
</sect2>

<sect2 id=gmDbObject><title>gmDbObject.py</title>
<screen>
 gmDbObject : base class for generic database objects
              this base class should provide a higher level database API      
              to the client programmers, since it takes care of
              some error handling and handles the differences
              between read-only and read/write connections

class DBObject:
    High level DB-API based base class for all gnumed database objects

    def __init__(self, dbbroker, service='default', select_query=None):
	    dbbroker: database broker as in gmPG.py
	    service: name of the gnumed database service the data is based on
	    select_query: query that selects the rows associated with class instance

    def SetSelectQuery(self, query):
	    Definition of the query string used to select the row(s)
	    associated with this database object. Parameters (for example for
	    a 'where' clause are allowed in
	     'dictionary parameter style', that is as '%(dictionary key)s'
	    All parameters have to be passed as strings, but no quoting!!!


    def SetInsertQuery(self, query):
	    Definition of the query that would insert a row into this
	    database object. All parameters must
	    be set in 'dictionary parameter style', that is as '%(dictionary key)s'
	    All parameters have to be passed as strings, but no quoting!!!


    def SetUpdateQuery(self, query):
	    Definition of the query neccessary to update the associated row.
	    The string must have a '%(primarykey)s' parameter which is representing the 
	    primary key attribute of the row to update. All other parameters must
	    be set in 'dictionary parameter style', that is as '%(dictionary key)s'
	    All parameters have to be passed as strings, but no quoting!!!


    def SetDeleteQuery(self, query):
	    Definition of the query neccessary to delete the associated row.
	    The string must have a '%(primarykey)s' parameter which is representing the 
	    primary key attribute of the row to delete


    def LogError(self, msg, map):
	    Please replace with gnumed logging functins s.a.p.


    def Select(self, map=None, maxfetch=0, listonly=0):
	    Executes the select query and returns a list of
	    PgResultSets (see pyPgSQL documentation)
	    dictionary 'map' can be used for query parameters, for
	    example for a 'WHERE' clause.
	    'maxfetch' limits the number of rows returned
	    'listonly' can speed things up if a large number
	    of rows is expected as result by returning a simple list
	    of lists instead of a list of PgResultSets

    def Insert(self, map):
	    insert a row with attributes as listed in the dictionary 'map'.
	    Returns the OID is succesful, otherwise returns 'None'


    def Update(self, map):
	    update a row with attributes as listed in the dictionary "map".
	    'map' dictionary  MUST contain the key 'primarykey' with the
	    value set to the primay key of the row to be updated
	    Returns 'None' if failed, the primary key if success 


    def Delete(self, map):
	    deletes a row as determined by the delete query string.
	    'map' dictionary  MUST contain the key 'primarykey' with the
	    value set to the primay key of the row to be deleted
	    Returns 'None' if failed, the primary key if success 
</screen>
</sect2>
</sect1>

<sect1 id=wxpython-modules><title>wxpython</title>
<sect2><title>gnumed.py</title><screen>
main wrapper setting up global brokers, logging, command line argument handling, i18n, etc.
GNUmed
======
This is the launcher for the main GNUmed GUI client. It is
intended to be used as a standalone program.

Command line arguments:

--quiet
 Be extra quiet and show only _real_ errors in the log.
--debug
 Be extra verbose and report nearly everything that's going
 on. Useful for, well, debugging :-)
--text-domain=<&lt a_text_domain &gt
 Set this to change the name of the language file to be loaded.
 Note, this does not change the directory the file is searched in,
 only the name of the file where messages are loaded from. The
 standard textdomain is, of course, "gnumed.mo".
--log-file=&lt a_log_file> &gt
 Use this to change the name of the log file.
 See gmLog.py to find out where the standard log file would
 end up.
--help, -h, or -?
 Well, show this help.


further action:
- import gmLog
- import gmI18N, gmGuiBroker, gmGuiMain
- import gmTalkback if necessary

jump to gmGuiMain.main()

</screen></sect2>
<sect2><title>gmGuiMain.py</title><screen>

GNUMed GUI client
The application framework and main window of the
all signing all dancing GNUMed reference client.

from wxPython.wx import *
from wxPython.html import *

import gmLogFrame, gmGuiBroker, gmPG, gmSQLSimpleSearch, gmSelectPerson, gmConf, gmLog, gmPlugin
import images
import images_gnuMedGP_Toolbar                 #bitmaps for use on the toolbar
import images_gnuMedGP_TabbedLists             #bitmaps for tabs on notebook
import gmGuiElement_HeadingCaptionPanel        #panel class to display top headings
import gmGuiElement_DividerCaptionPanel        #panel class to display sub-headings or divider headings 
import gmGuiElement_AlertCaptionPanel          #panel to hold flashing alert messages
import gmGP_PatientPicture                     #panel to display patients picture 
import gmGP_Toolbar                            #panel with two toolbars on top of the screen

from gmI18N import gmTimeformat

class MainFrame(wxFrame):
	GNUmed client's main windows frame
	This is where it all happens. Avoid popping up any other windows.
	Most user interaction should happen to and from widgets within this frame

	def __init__(self, parent, id, title, size=wxPyDefaultSize):
		You'll have to browse the source to understand what the constructor does

		# initialize the gui broker
		# allow access to a safe exit function for all modules in case of "emergencies"
		# setup status bar
		# allow all modules to access our status bar
    	    	
		# connect to backend

    	    	# get current user and display it

    	    	# setup platform dependent data
		# create menus
		# setup accelerators
		# register events

		# create the  the main sizer to contain all the others on the form
		# create a top vertical box sizer for the main window
	
		# create a horizontal sizer which will contain all windows at the top of the
		# screen (ie menu's and picture panel - which are on sub sizers)
		# add a wxPanel to this sizer which sits on the left and occupies 90% of width
		# followed by panel for the patients picture which occupies 10%. Add labels for
		# demo patients

		# setup the "top row", where all important patient data is always on display
		# set up the main notebook (gmNotebook)
		# relate plugins to the notebook (via gmPlugin.GetAllPlugins ('gui'))
		# position the Window on the desktop and show it


	def SetupPlatformDependent(self):
		#do the platform dependent stuff

	def OnNotebook (self, event):
		Called when notebook changes

	def RegisterEvents(self):
		#register events we want to react to

	def OnAbout(self, event):
		" A simple 'about' dialog box"

	def SetupAccelerators(self):
	def SetupStatusBar(self):
		#add time and date display to the right corner of the status bar
		#update every second

	def Notify(self):
		Displays date and local time in the second slot of the status bar"

	def CreateMenu(self):
		Create the main menu entries. Individual entries are
		farmed out to the modules

	def Lock(self):
		Lock GNUmed client against unauthorized access"

	def Unlock(self):
		Unlock the main notebook widgets
		As long as we are not logged into the database backend,
		all pages but the 'login' page of the main notebook widget
		are locked; i.e. not accessible by the user

		#unlock notebook pages
		# go straight to patient selection

	def OnFileExit(self, event):

	def CleanExit(self):
		This function should ALWAYS be called when this
		program is to be terminated.
		ANY code that should be executed before a regular shutdown
		should go in here
    
    	def OnClose(self,event):

	def OnIdle(self, event):
		Here we can process any background tasks

	def OnIconize(self, event):

	def OnMaximize(self, event):

	def OnPageChanged(self, event):

class gmApp(wxApp):
	def OnInit(self):
		# do platform dependent stuff
		# create a static GUI element dictionary;
    	    	# show the login window
		# create the MainFrame		

def main():
	GNUmed client written in Python
	to run this application simply call main() or run the module as "main"
	#create an instance of our GNUmed main application
	#and enter the main event loop

gnumed.py calls gmGuiMain.main() 
gmGuiMain.main() creates gmApp
gmApp creates MainFrame
MainFrame sets up the toolbar, top row, Menus (items will be added by the plugins)
main sizers and loads all plugins in directory wxpython/gui

gmApp enters wx event loop, waiting for some action


</screen></sect2>
<sect2><title>gmAppoint.py</title><screen>
# gmAppoint - A simple interface to the appointments book.
#             INCOMPLETE, do not link in to rest of app.

</screen></sect2>
<sect2><title>gmCryptoWidget.py</title><screen>

This module implements a ""crypto"" aware text widget

This text widget allows arbitrary text to be entered via keyboard,
cut'n paste via clipboard, or text files via drag'n drop
Right clicking pops up a menu that allows to encrypt or decrypt
the selected text segment.

class gmTextctrlFileDropTarget(wxFileDropTarget):
     a generic text control widget that accepts dropped files 

    def __init__(self, textwindow):
    def OnDropFiles(self, x, y, filenames):
        inserts the dropped file(s) content(s) at the cursor position

class gmCryptoText(wxTextCtrl):
    A special text widget that supports cryptography

    A right mouse click pops up a manu that allows to encrypt
    or decrypt selected text segments.
    You can drag and drop any number of text files into the text
    widget, and that text will be inserted at the current cursor
    position

    def __init__(self, parent, id, size=wxPyDefaultSize, style=wxTE_MULTILINE|wxTE_RICH, defaulttext=None):

    def OnRightClick(self, event):
        A right mouse click triggers a popup menu for cryptographic
	functionality"

    def OnContextMenu(self, event):

    def OnEncrypt(self, event):
        triggered by popup contect menu event

    def OnDecrypt(self, event):
    def OnSetPassphrase(self, event):
    def OnRightDown(self, event):
        dummy function; if this event was not intercepted, GTK would
        clear the text selection the very moment the mouse button is clicked

    def AskForPassphrase(self):
        asks for a pass phrase and returns it

    def Encrypt(self, cleartext, key):
        override this function for your own crypto funcs

    def Decrypt(self, ciphertext, key, identtag):
        override this function for your own crypto funcs

    def StripIdentTag(self, text):
        Remove the 'ident tag' from text and return both tag and test
    def GetIdentTag(self):
        This is a 'virtual' function which should be overridden to provide your own meaningful tag

    def SetFuzzyMargin(self, margin):
        The fuzzy margin is the number of characters on each side of the text selection
        the decryption algorithm will search for correct delimiters. It should be at least as long as
        the IdentTag is plus an extra 3 characters to allow for the crypto tag

    def FuzzyScanSelection(self, frompos, topos, margin):

</screen></sect2>
<sect2><title>gmEditArea.py</title><screen>
The classes in this file are not used until now. 

class  EditAreaTextBox(wxTextCtrl):
#text control class to be later replaced by the gmPhraseWheel
	def __init__ (self, parent, id, wxDefaultPostion, wxDefaultSize):

class EditAreaPromptLabel(wxStaticText):
#Class which shows a blue bold label left justified
	def __init__(self, parent, id, prompt, aColor = richards_blue):

class EditAreaPrompts(wxPanel):
#create the editorprompts class which expects a dictionary of labels passed to it
#with prompts relevent to the editing area.
	def __init__(self,parent,id,prompt_array):

class EditTextBoxes(wxPanel):
#Class central to gnumed data input
#allows data entry of multiple different types.e.g scripts,
#referrals, measurements, recalls etc
#section = calling section eg allergies, script

have a look at the source code if you want to know what it is doing.

</screen></sect2>
<sect2><title>gmGuiElement_AlertCaptionPanel.py</title><screen>
base classes for captioned alert divider on left hand side of
notebook page "patient"
</screen></sect2>
<sect2><title>gmGuiElement_DividerCaptionPanel.py</title><screen>
base classes for captioned dividers on left hand side of
notebook page "patient"
</screen></sect2>
<sect2><title>gmGuiElement_HeadingCaptionPanel.py</title><screen>
base classes for captioned heading divider on left hand side of
notebook page "patient"

gmGuiMain.py
- inits wxPython GUI framework

</screen></sect2>
<sect2><title>gmLogFrame.py</title><screen>
not used anymore, really

</screen></sect2>
<sect2><title>gmLoginDialog.py</title><screen>
encapsulates the first dialog, the login window.
should be del()ed after use, actually

</screen></sect2>
<sect2><title>gmLogin.py</title><screen>
- encapsulates the login information as a python object

</screen></sect2>
<sect2><title>gmMDWImporter.py</title><screen>
- not related to framework
- implements data import from on commercial australian medical
  software

</screen></sect2>
<sect2><title>gmShadow.py</title><screen>
- encapsulates custom widget shadow object to be used on all
  Richard-Terry-Style widgets (possibly more)

</screen></sect2>
<sect2><title>gmUserAdmin.py</title><screen>
- unrelated to framework as of now
</screen>
</sect2>
</sect1>

<sect1 id=gui-plugins><title>wxpython/gui - "whole page" plugin widgets regarding the notebook</title>
<para>TODO</para>
</sect1>
<sect1 id=gui-plugins-de><title>wxpython/gui-de - same as ../gui for Germany (AMIS-browser should life here)</title>
<para>TODO</para>
</sect1>

<sect1 id=patient-plugins><title>wxpython/patient - "patient page" plugin widgets</title>
<para>TODO</para>
</sect1>
	
</chapter>

    <chapter id=design>
    	<title> Design </title>

	<sect1 id=resources>
	<title>Resources</title>
	<para>
	Various design documents can be found at the following locations:
	</para>
	<itemizedlist>
	<listitem><para><ulink url="http://gnumed.org/docs">
	<citetitle>gnumed.org/docs</citetitle></ulink></para></listitem>
	<listitem><para><ulink url="http://resmedicinae.sourceforge.net/analysis/index.html">
	<citetitle>Resmedinae - Analysis document</citetitle></ulink></para></listitem>
	<listitem><para><ulink url="http://gnumed.net/rterry/Index.htm">
	<citetitle>Richard Terry's Design Principles</citetitle></ulink></para></listitem>
	</itemizedlist>
	</sect1>
	
	<sect1 id=db-architecture>
	    <title>GNUMed Database Architecture</title>
	    <para>
	    Supplied by Horst Herb
	    </para>
    	    <sect2>	
    	    	<title>Client-Server architecture with optional middleware layers</title>
    	    	<para>
    	    	GNUMed is designed as a <emphasis>client-server</emphasis> architecture with <emphasis>optional middleware</emphasis> components.
		The database backend is provided by PostgreSQL, a largely SQL-92 compliant  object-relational
		database server. PostgreSQL is free software, obtainable at http://www.postgresql.org. 
		It is portable, running on virtually all Posix compatible systems including Gnu/Linux, 
		BSD Unix, Solaris, Mac OS/X. Although we do not recommend it, it can be run on Microsoft
		Windows NT, 2000 and XP.
    	    	</para> 
    	    </sect2>
            <sect2>
	    	<title>Distribution of database services</title>
    	    	<para>
    	    	GNUMed allows distributions of database services. Closely related information like a person's
		name and address are regarded as a "service", which may or may not be hosted on the same physical 
		server as other services. Developers have to refer to the list of services when designing database 
		queries. A <emphasis>central pivot database</emphasis> provides information about the nature and whereabouts of 
		distributed services. On the client side, distribution is made transparent to the developer
		and end user through a <emphasis>"database service broker"</emphasis> object which not only hides information about
		service distribution, but can also be used for load balancing , reusable connections and database
		replication in future versions. 
    	    	</para>
	    </sect2>
    	    <sect2>
	    	<title>Normalization of data</title>
    	    	<para>
    	    	Tables are <emphasis>normalized</emphasis> to the  3rd normal form as long as this does not deteriorate query performance
		too much. In order to simplify client software development, a <emphasis>pseudo-denormalization</emphasis> is achieved through
		updateable views. Foreign key constraints ensure <emphasis>referential integrity</emphasis> of highly normalized data.
		Reference counter tables keep track of <emphasis>cross-database relational integrity</emphasis>, as PostgreSQL does not allow
		(yet) cross-database constraints and queries.
		</para>
    	    </sect2>
    	    <sect2>
	    	<title>Audit trailing</title>
    	    	<para>
    	    	<emphasis>Trigger functions</emphasis> ensure business logic and <emphasis>audit trailing</emphasis> . Deleting and updating of data is caught by
		triggers, and copies of the originals are kept in audit trail tables at all times. Database programmers
		need not to worry about this, as all audit trail related triggers and tables are generated automatically.
		In order to achieve this, we do use postgres specific extensions such as table inheritance and built-in 
		procedural languages such as pgsql, pgtcl and pgpython. Thus, gnumed can not be
    	    	easily ported to a different database backend.
    	    	</para>
    	    </sect2>
    	    <sect2>
	    	<title>Access control</title>
    	    	<para>
    	    	The PostgreSQL server supports <emphasis>secure authentication protocols</emphasis> such as Kerberos as well as <emphasis>secure
		communication protocols</emphasis> between client and server(s) such as SSL. In addition, data of more strictly
		confidential data wil be stored encrypted with arbitrary algorithms; although the cryptographic process
		is performed on the client side, this is supported by the GNUMed server through a sophisticated key management.
		A user hierarchy can be implemented, and access to tables and procedures can be regulated through this hierarchy
		on the server side.
    	    	</para>
	    </sect2>	
    	    <sect2>
	    <title>Multigenerational concurrency control and backups</title>
    	    <para>
    	    PostgreSQL uses a multigenerational concurrency control system. This not only avoids most locking situations,
	    but also allows <emphasis>life "snapshot" backups</emphasis> of the complete database system while the system is running even under
	    full load.
	    </para>
	    </sect2>
    	</sect1>


	<sect1 id=services>
	    <title>List of distributed database services</title>
	    <para>
	    Supplied by Horst Herb
	    </para>
    	    <sect2>
	    <title>Configuration - the service administering all other services</title>
	    <para></para>
	    </sect2>	

    	    <sect2>
    	    	<title>Person related services</title> 

    	    	<informaltable frame=all>
    	    	    <tgroup cols=2>
    	    	    <colspec colwidth="1*">
    	    	    <colspec colwidth="5*">
    	    	    <tbody>
    	    	    	<row><entry>Service name:</entry><entry>Personalia</entry></row>
    	    	    	<row><entry>Provides:</entry>
    	    	    	    <entry><itemizedlist mark=opencircle>
    	    	    	    	<listitem><para>
    	    	                    All information directly related to a person's identity, biological and social relationships
                    	    	    excluding confidential data (like credit card information) 
				</para></listitem>
				<listitem><para>
    				    All geographical information, including  
				</para></listitem>
				<listitem><para>
                		    Personal communication related information (phone numbers, fax, email, web sites, pagers) 
				</para>
				</listitem>
				</itemizedlist></entry></row>
    	    	    	<row><entry>Access level:</entry><entry>all staff</entry></row>
    	    	    </tbody>
    	    	    </tgroup>
		    <tgroup cols=3>
			<colspec colwidth="1*">
			<colspec colwidth="1*">
			<colspec colwidth="3*">
			<tbody>
			    <row><entry>Related Scripts:</entry><entry>gnumed.sql</entry>
			    <entry> priming of database (creation of procedural languages, basic access
                                    permissions, audit trail priming)
			    </entry></row>
			    <row><entry></entry><entry>gmgis.sql</entry><entry>
                            	    geographic information in the widest sense; streets, cities, states, nations,
                            	    postcodes ...
			    </entry></row>
			    <row><entry></entry><entry>gmidentity.sql</entry><entry>
                            	    a person's identity, names, relationships, and a many-to-many pivot table
                            	    linking identities to addresses
			    </entry></row>
			    <row><entry></entry><entry>gmcommunication.sql</entry><entry>
                            	    phone & fax numbers, email addresses, web sites, pagers, etc. and a
                            	    many-to-many pivot table linking identities to communication URLs
			    </entry></row>
			</tbody>
		    </tgroup>
    	    	</informaltable>

	    </sect2>	

    	    <sect2>
        	<title>Medical history related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    past medical  history / diagnoses 
		    </para></listitem>
		    <listitem><para>
		    active medical problems
		    </para></listitem>
		    <listitem><para>
		    progress reports
		    </para></listitem>
		    <listitem><para>
		    social history 
		    </para></listitem>
		    <listitem><para>
		    family history 
		    </para></listitem>
		    <listitem><para>
		    substance abuse history 
		    </para></listitem>
		    <listitem><para>
		    allergies 
		    </para></listitem>
		    <listitem><para>
		    vaccinations
		    </para></listitem>
		    <listitem><para>
		    past medication & current prescriptions
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>External results </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    pathology results 
		    </para></listitem>
		    <listitem><para>
		    imaging results
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>Correspondence </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    sent documents (referrals, certificates) 
		    </para></listitem>
		    <listitem><para>
		    received documents (discharge summaries, specialist reports)
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>Pharmaceutical reference </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    drug listing: generic and brand names 
		    </para></listitem>
		    <listitem><para>
		    drug properties 
		    </para></listitem>
		    <listitem><para>
		    consumer product information  
		    </para></listitem>
		    <listitem><para>
		    interactions
		    </para></listitem>
		</orderedlist>
	    </sect2>	
    	    
	    <sect2>
    	    	<title>General medical reference </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    coding (i.e. LOINC, ICD-10)
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	    	<title>Decision support database </title>
    	    	<para></para>
	    </sect2>	
    	    
	    <sect2>
    	        <title>Large binary objects (BLOBS)</title>
    	    	<para></para>
	    </sect2>	
    	    
	    <sect2>
    	        <title>Accounting related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    billing 
		    </para></listitem>
		    <listitem><para>
		    tax related information 
		    </para></listitem>
		    <listitem><para>
		    stock tracking
		    </para></listitem>
		    <listitem><para>
		    ordering supplies
		    </para></listitem>
		</orderedlist>
	    </sect2>	
    	    <sect2>
    	       <title>Office related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    waiting room 
		    </para></listitem>
		    <listitem><para>
		    appointments 
		    </para></listitem>
		    <listitem><para>
		    recalls 
		    </para></listitem>
		</orderedlist>
    	    </sect2>
    	</sect1>	


    	<sect1 id=signals>
	    <title>List of GnuMed client internal signals</title>
	    <para>
	    Supplied by Horst Herb
	    </para>
                    
    	    <para>         
	    All signals are defined in the module gmSignals.py, located in the source
	    tree under gnumed/client/python-common.</para>
	    <para>
	    Developers never should use these signal strings directly, but always refer
	    to the signal strings via their factory functions in the module gmSignals.</para>
	    <para>
	    The name of the factory function is identical with the signal it represents:
	    gmSignals.popup_notice() would thus return the string 'popup_notice'.
	    </para>
	    <para>
	    However, these factory functions <emphasis>may</emphasis> do more than just that; they
	    can also trigger a 'listen' signal for asynchronous backend notifications,
	    and they can do some house keeping in order to avoid that the same callback
	    is triggered multiple times unneccessarily.
	    </para>

    	    <para>
		<table frame=all>
		<title>Signals</title>
		<tgroup cols=4>
		    <colspec colname=c1>
		    <colspec colname=c2>
		    <colspec colname=c3>
		    <colspec colname=c4>
		    <spanspec spanname=hspan namest=c1 nameend=c4 align=center>
		    <thead>
			<row>
			    <entry>Signal</entry>
			    <entry>Meaning</entry>
			    <entry>Parameter(s)</entry>
			    <entry>Origin</entry>
			</row>
		    </thead>
	      	    <tbody>

		    <row><entry spanname=hspan><emphasis>General messages</emphasis></entry></row>
    	    	    <row>
			<entry>popup_notice</entry>
        		<entry>A popup notice wants to be displayed (can be disabled if 
			client does not want to be interrupted)</entry>
        		<entry><itemizedlist mark=closedcircle>
		    	    <listitem><para>id_sender (ID of sender)</para></listitem>
		    	    <listitem><para>id_recipients ( IDs of recipients  as list (-1 = broadcast message))</para></listitem>
			</itemizedlist></entry>
        		<entry>Frontend or Backend</entry>
		    </row>
        	    <row>
        	    	<entry>popup_alert</entry>
        	    	<entry>A popup alert wants to be displayed (high priority 
			message - should not be disabled by the client)</entry>
        	    	<entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_sender (ID of sender) id_recipients</para></listitem>
			    <listitem><para>( IDs of recipients  as list (-1 = broadcast message))</para></listitem>
			    </itemizedlist></entry>
        	    	<entry>Frontend or Backend</entry>
		    </row>

		    <row><entry spanname=hspan><emphasis>"Current patient" related messages</emphasis></entry></row>
		    <row>
        		<entry>patient_selected</entry>
        		<entry>A patient has been selected within the client user interface. This 
			 patient is now the "current" patient. All widgets displaying client data
			 must update themselves accordingly</entry>
        		 <entry>id_patient (ID of patient)</entry>
        		 <entry>Frontend</entry>
		   </row>
		   <row>
        	     <entry>patient_modified</entry>
        	     <entry>A patient's demographic data has been updated. Widgets displaying a
		      patient's demographic data must update themselves</entry>
        	     <entry>id_patient (ID of patient)</entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		   <row>
        	     <entry>medication_modified</entry>
        	     <entry>The current patient's medication has been modified. Medication related
		      widgets have to update themselves. This can also be used for drug interaction
		      checking, drug allergy checking etc. </entry>
        	     <entry>id_patient (ID of patient)</entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
    	    	    
		    <row><entry spanname=hspan><emphasis>Waiting room related</emphasis></entry></row>
		   <row>
        	     <entry>waitingroom_added</entry>
        	     <entry>A patient has been added to the waiting room</entry>
        	     <entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_patient (ID of patient)</para></listitem>
			    <listitem><para>id_doctor (ID of doctor to see patient)</para></listitem>
	    	     </itemizedlist></entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		   <row>
        	     <entry>waitingroom_incons</entry>
        	     <entry>A patient has entered a consultation (is seen by a doctor)</entry>
        	     <entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_patient (ID of patient)</para></listitem>
			    <listitem><para>id_doctor (ID of doctor to see patient)</para></listitem>
		     </itemizedlist></entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		   <row>
        	     <entry>waitingroom_left</entry>
        	     <entry>A patient has left the waitingroom (finished consultation)</entry>
        	     <entry><itemizedlist mark=closedcircle>
			    <listitem><para>id_patient (ID of patient)</para></listitem>
			    <listitem><para>id_doctor (ID of doctor to see patient)</para></listitem>
		     </itemizedlist></entry>
        	     <entry>Frontend or Backend</entry>
		   </row>
		</tbody>
        	</tgroup>
		</table>
    	</sect1>

	<sect1 id=faq>
	<title>FAQ</title>
    	<para>
> I would be interested in hearing about the database design 
> history and the purpose of the distributed database architecture
> that you have implemented, (smart, but possibly a little 
> over-kill I would have thought at first glance).
    	    </para>
	    <para>
	    Horst Herb:The main reason why we had to split the monolithic backend up:
- some countries provide centralized demographic information. It would 
be inefficient and unreliable to try to copy such a centrally well 
maintained demographic database. We should rather allow to tap into it 
via distributed services.
- some countries provide centralized pharmaceutical information
- some countries provide centralized immunisation databases
- some conutries centralize certain pathology results
etc.

Sometimes, this happens on a smaller scale like within a hospital where 
they already have successfully implemented some of these services, they 
are running smoothly, and they find no reason to pull it apart again. 
GNUMed will shine in such an environment because it will be far easier 
to integrate into such existing solutions than other software.

Thus we try to find out which "services" are relatively independent from 
others, and isolate them into particular "virtual" databases. That 
way, it will be magnitudes easier to write simple wrappers for external 
sources and use them.

The main obstacle is tha Postgres in itself does not support 
cross-database queries, and we have to take care of referential 
integrity between external sources ourselves.

Note: we should put in a description on how this is achieved now
(client side) vs. how we would want this (either built into postgres
or via a dedicated demon on the backend with listen/notify)
	    </para>
	    
	    <para>
	    Karsten Hilbert: 
There isn't really much choice: Doing everything in one
monolithic database isn't quite flexible enough (distributed
practices with a WAN link, remote clinical repository but
local drug information data store). The difference between
hardcoding 2 or 3 database and doing it the Right Way as we
are trying to do now isn't very much of a difference. So there
aren't really many steps inbetween "monolithic" and
"distributed according to some configuration". Yes, it's a bit
more complex but to the client side it shouldn't be any more
complex than:

dbbrooker.GetConnection('personalia')
dbbrooker.GetConnection('BLOBS')

If we then properly encapsulate accesses into objects we don't
experience too much pain in using the distributed version.

It does get a bit more involved with keeping strict
referential integrity across databases but Horst can explain
the issues better than me.
    	    </para>
	    
	</sect1>

	<sect1 id=EMR-design>
	    <title>Gnumed EMR</title>

    	    <sect2>
		<title>Required reading</title>
	    	<para>
		Weed: the problem-oriented medical record (SOAP, POMR)
		 use Google
		</para><para>
		Slee: loss-free entity coding in medicine
		 (See <ulink url="http://www.tringa.com/index.php?submit=HCCC"><citetitle>http://www.tringa.com/index.php?submit=HCCC</citetitle></ulink>)
		</para><para>
		Dutch model: Episodes of Care
		 (See <ulink url="http://www.phcsg.org.uk/conferences/cambridge1998/westerhof.htm"><citetitle>http://www.phcsg.org.uk/conferences/cambridge1998/westerhof.htm</citetitle></ulink>)
		</para>
	    </sect2>
    	    <sect2>
		<title>Structural considerations</title>

    	    <sect3>
		<title>Health Issue</title>
	    	<para>
		A Health Issue is a longer ranging medical condition associated with
		a patient. There may be several episodes related with one health
		issue and there must be at least one. At times a health issue will
		first be appreciated by considering underlying similarities between
		several medically related episodes. A health issue may have a finite
		duration if the underlying medical condition is eventually fully
		resolved. It may also span the entire life of the patient such as
		in chronic or genetic ailments. Start and end are not directly
		recorded but must be derived from the start of the earliest and
		the end of the most recent associated episode.
		</para>
	    </sect3>
    	    <sect3>
		<title>Clinical Episode</title>
	    	<para>
		A Clinical Episode denotes a period of time during which the patient
		was under care for one particular Health Issue (medical condition).
		Several episodes (eg. progression, bouts, etc.) may be associated
		with a particular health issue. There can be several encounters per
		episode, there must be at least one. The start and end of an episode
		isn't directly recorded but rather one can deduce that data from the
		associated clinical items of which there will usually be several
		(but at least one). Often, several providers will contribute to an
		episode of care (via several encounters and items). One would think
		that episodes can be deduced from clusters of closely related dates
		of clinical encounters. While this is true it cannot be used reliably
		in a programmatic way.
		</para>
		</sect3>
    	    <sect3>
		<title>Clinical Encounter</title>
	    	<para>
		A one-off contact between patient and health care system (or on behalf
		of the patient) is called a "Clinical Encounter". An encounter is often
		restricted to a given date but may span midnight and will thus refer to
		two dates. The date itself is not directly stored in the encounter
		table clin_encounter but must be determined from the commit timestamps
		of the clinical items belonging to it. The encounter table records the
		location, provider and subject of care as well as the type of encounter.
		It really is more of an administrative than a purely clinical concept.
		Note that it also does not fit hospital stays particularly well where
		it is harder to define clean boundaries between encounters. One
		encounter will often relate to more than one episode/health issue.
		</para>
	     </sect3>
    	    <sect3>
		<title>Clinical Item</title>
	    	<para>
		In GnuMed a medically meaningful piece of information is called "Clinical
		Item". Such items are typically elements of the SOAP structure such as a
		diagnosis, a history item, an assessment, a plan, etc. Several tables,
		both specific and generic store such items. They all inherit from the
		table clin_root_item which records the Clinical Encounter and Clinical
		Episode this item belongs to. Virtue of inheriting from clin_root_item all
		Clinical Item tables also have a generic "narrative" field for comments
		and clinical narrative.
		</para>
	     </sect3>		
    	    <sect3>
		<title>Partial Contact</title>
	    	<para>

		This concept of the Dutch Episode Model is not directly
		represented in the GnuMed clinical table structure. It is
		easily derived from the existing data by aggregating all
		Clinical Items that belong to the same Clinical Encounter
		and the same Clinical Episode.
		</para>
	    </sect3>
	    </sect2>
	    
    	    <sect2>
		<title>Implementation considerations</title>

    	    <sect3>
		<title>Clinical narrative</title>
	    	<para>
		Due to the fact that clinical items are stored in several different
		specific and non-specific tables it is difficult to do a full-text
		search across the medical record of a patient. For this reason all
		clinical narrative is aggregated in the clin_root_item table. All
		tables providing clinical narrative are supposed to inherit from
		this table. If more than one field for free text is needed in a
		table links to entries in clin_note must be used additionally
		to the inherited clin_root_item.narrative field.
	    	</para>
	    	<para>
		The view v_patient_items provides an aggregation of clinical
		items per patient. From this one can derive the item ID and source
		table of individual items. It also provides the full text of the
		clinical narrative for all tables that inherit from clinical item.
		Only very few clinically relevant narrative strings are not stored
		in such tables, namely comments on clin_episode, clin_encounter
		and clin_health_issue rows.
	    	</para>
	    </sect3>
	    
    	    <sect3>
		<title>View v_pat_episodes</title>
	    	<para>
		This view links episodes to patients.
		</para>
	    </sect3>
    	    <sect3>
		<title>View v_i18n_curr_encounters</title>
	    	<para>
		This view shows the current encounters and provides a translated
		encounter type (if a translation is available).
		</para>
	    </sect3>
    	    <sect3>
		<title>Predefined data</title>
	    	<para>
		Wherever fixed strings are predefined for certain fields (such
		as descriptions of encounter types or history item types) provisions
		for translation of those strings via gmI18N.sql must be made. An
		ID range for user-supplied additional strings must be defined. The
		default language is English, other languages are handled via
		translations. In appropriate cases views may facilitate easier
		access to translated strings. Names of such views are to be
		prepended by "v_i18n_".
		</para>
	    </sect3>

    	    <sect3>
		<title>Clinical items</title>
	    	<para>
		All tables holding clinical items must inherit from clin_root_item.
		</para>
	    </sect3>
	    </sect2>
	    
    	    <sect2>
		<title>Medical relation between entities</title>
	    	<para>
		<screen>
health issue
-> several episodes
   -> several encounters
      -> several partial contacts
         -> several items
		</screen></para>
	    </sect2>
	</sect1>


	<sect1 id=gui-design>
	    <title>GUI design</title>

    	    <sect2>
		<title>General</title>
	    	<para> (Taken from Richards Terrys Design Philosophy at www.gnumed.net/rterry)</para>
		<para>
		<itemizedlist mark=opencircle>
		   <listitem><para>Uncluttered screen without wasting screen real estate.</para></listitem>
		   
		   <listitem><para>Pleasant, aesthetic view.</para></listitem>
		   
		   <listitem><para>As few as possible pop-up elements; static screen elements should be given preference.</para></listitem>

		    <listitem><para>
		      As few as possible modal forms. Data belonging together should be on the same visual plane. Peripheral information should not distract the attention attention.
		    </para></listitem>

		    <listitem><para>
		      Core information (eg medications, tasks to do during consultations, recalls etc) should be visible while working in different sections.  		      
		    </para></listitem>

		    <listitem><para>Use of colors to highlight and separate information. The use of colors should be customizable.
		    </para></listitem>

		    <listitem><para>
		    Data entry and presentation should follow a recurring pattern. The same type of information should be displayed and entered at the same place in different sections where possible.
		    </para></listitem>

		    <listitem><para>
		      Program control: Primarily keyboard oriented control, every action should be accessible via keyboard shortcuts
		      Mouse oriented control must be possible, too.
		    </para></listitem>
		    <listitem><para>Ease of use:
		      Only very few steps to find an option. Key strokes should be kept to a minimum.key strokes should be kept to a minimum,
		      there should be no heavy reliance on menu's. 
    	    	    </para></listitem>
		    <listitem><para>Customizability: The program should provide the user with timely and appropriate information in his style and language. 
		    </para></listitem>
		    <listitem><para>Contextual and weighted data presentation: If possible, information should be presented in a weighted and contextual fashion. Statistics about information use should be collected in these cases.
		    </para></listitem>

		  </itemizedlist>
    	    	<para>

    	    	<sect2>
		    <title>Date Entry Paradigm - The Editing Area</title> 
		    <para>Medical information usually can be presented as groups of 4-10 parameters. 
		    It is therefore possible to come up with a gui design for data entry where 
		      all segments of a medical records program use the same format of data input. 
		    In GnuMed this fact is reflected by a graphic 
		      design that is called the 'editing area'. 
		    </para>

		    <para>The area of the screen where data is entered (`editing area) will be implemented as an widget which can be customized to the various groups of medical information. </para>
		      <para>This editing area does not 'pop up' in a window. It stays in the same place 
		      on the screen but changes appearance according to the type of data the user 
		      is entering.</para>
		    <para> Because it looks and functions the same, no matter 
		      what category of data is being entered, there is no need to for the user to 
		      learn how to use multiple sections of a program, no need to have multiple different 
		      designs of pop up dialogs as is common in most medical programs.</para>
		    <para>In addition, as a programmer will quickly realise, 
		      it can lead to a reduction in computer code needed to generate the display and 
		      call in information from the database for contextual display, as generic subroutines 
		      can be developed to work across all sections of medical information. </para>
		    <para>In most sections of the program the user enters 
		      very little information as most of it will be 'autofilled' in by the program. In GnuMed, The 
		      context of the editing area can be called from a button bar. </para>
		  
		    <para>In the following there are shown some examples of it's implementation. 
		      These screen dumps have been taken from an already functional VisualBasic-based medical records program written by Richard Terry. 
		      The graphical interface of GnuMed will be quite similiar to that of some of the examples shown.
		      First examples of variations of the editing area, followed by screen 
		      dumps of the whole program, accompanied by comments by Richard Terry.</para>
    	    	</sect2>
		
		<sect2>
		    <title>Full Screen Design</title>
		    <para>The following is the rough 
		      template used for designing the whole screen. The proportions are roughly 
		      shown below.</para>
		    <para>
		      Though the area designated 
		      for the tab control (which contains lists for medications, pathology, referral 
		      letters, recalls etc) may seem small, in practice it works well. There is enough 
		      room here for eg 10-14 medications and if filled, that in itself would indicate 
		      the patient was probably suffering from poly-pharmacy!. Other lists eg pathology 
		      are viewed in decending order, ie most recent to least recent, and are usually 
		      able to be sorted by date/type of request etc hence information is easily seen 
		      or quickly found. Just how many requests/referrals/recalls does the average 
		      patient have in year anyway, usually very few.</para>
		    <para>The 'scratch pad' area I've found immensely useful. 
		      The doctor enters free hand text here for those little reminders one needs which 
		      may not be 'medical reminders' or could be personal memory joggers for the doctor.</para>
		    <para>The lower right hand area contains any outstanding 
		      reviews/recalls which are presented as the recall name and months due/overdue.</para>
		    <para>The size of the left hand rectangle (which here 
		      contains the editing area and some lists) is large enough and proportionately 
		      sized enough to display a variety of information e.g. referral letter text, 
		      pathology results, imaging results, graphs with decision support. I.e, one could 
 clicking on the drug display 
		      its product information, or if browsing the pathology list display the results 
		      of a test in this area</para>
		    <para>The editing area always occupies the central portion 
		      of this area and changes display according to the section of the program one 
		      is working on, although it may at times be temporarily covered by a display 
		      which uses the whole of this left hand pane.</para>
		    <para>The best way to see how this all works is to view 
		      the screen dumps shown on the following pages.</para>
		    <screenshot><graphic fileref="snapshots/Full_screen-general_description.png"></graphic>
		    </screenshot>		
		</sect2>
	</sect1>

    	<sect1 id=login-screen>
	    <title>Login Screen</title>
	    <sect2>
		<title>Short description</title>

    		<para>
		User authentication , possibility to choose login options.
		</para>

    	    </sect2>

	    <sect2>
		<title>Data Shown/Accessible</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>user name [free text]</para></listitem>
		    <listitem><para>user password [free text]</para></listitem>
		    <listitem><para>GnuMed database name [free text, choose from list]</para></listitem>
		    <listitem><para>GnuMed database host name [free text, choose from list]</para></listitem>
		    <listitem><para>GnuMed database host port [free text, choose from list]</para></listitem>
		    <listitem><para>GnuMed database options [free text, choose from list]</para></listitem>
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Functionality</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Get user name and password</para></listitem>
		    <listitem><para>Change GnuMed database options (database name, host, port of database server, database options)</para></listitem>
		    <listitem><para>Try to start GnuMed using the given user and options.</para></listitem>
		    <listitem><para>Remember the user/options used at the last login attempt.</para></listitem>
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Internals / Additional Information</title>
		<para>
		GNUMeds design allow connection to arbitrary servers. The server of choice is simply
		entered into the "host" text entry field. This is handy to connect to a replicated backup server in case
		of a failure of the primary server. It also allows to replicate the database onto the workstation
		and work separated from the net. As we are using TCP/IP (with optional SSL/TL secure protocol layers,
		the server can be located anywhere in the world. This allows for example a doctor to access a visiting patient's
		health record without importing / exporting data first. It also allows for centralized  record keeping in
		practices with multiple locations, or it allows a doctor to access his records from home.
		</para>

		<para>
		After entering the password and hitting enter (or after clicking onto the login button), the client attempts
		a server backend connection. If successful, the connection is logged and the GnuMed main screen displayed. The users
		preferences are loaded and the client configured accordingly. This can involve a complete reconfiguration
		of the client user interface. As the client remembers the last state before
		it was closed the last time, no configuration will be neccessary (unless it involves confidential settings)
		if always the same user uses this particular workstation.
		</para>

		<para>
		After a succesful login (and succesful user configuration) the first page of the notebook is opened automatically
		and the cursor is placed inthe "patient selector" search expression combo box, ready to search for a specific patient.
		</para>

    	    </sect2>

    	</sect1>

    	<sect1 id=main-toolbar>
	<title>Main Toolbar</title>

	    <sect2>
		<title>Short Description</title>

    		<para>
		Toolbar which is always present and holds menus, icons to change tools and generally important information.
		</para>

    	    </sect2>

	    <sect2>
		<title>Data Shown/Accessible</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Menus of all notebook pages / tools etc [scroll down menus]</para></listitem>
		    <listitem><para>Tool bar specific to the current module (notebook page) [icons]</para></listitem>
		    <listitem><para>Generally important information specific to the current module such as patient photo, name, allergies in the 'patient' module [various]</para></listitem>			
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Functionality</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Hold all menus.</para></listitem>
		    <listitem><para>Hold tool icons and generally important information specific to the current module</para></listitem>
		</itemizedlist>
    	    </sect2>

    	    <sect2>
	    <title>Internals / Additional Information</title>
	    <para>
	    <emphasis>The patient photo:</emphasis> if available, the most recent photograph of the patient will be displayed.
	    Clicking on the photograph will open the patient details notebook page below. A right click will reveal
	    a menu allowing to browse other photographs of this patient.
	    </para>

	    <para>
	    <emphasis>Personal details</emphasis>: The most important items from the personal details of the patient. Configurable.
	    </para>
	    <para>
	    <emphasis>Allergies &amp;</emphasis> Warnings Configurable. Colour coding etc. available to discretely display warnings like
	    "drug seeking behaviour"
	    </para>

	    <para>
	    <emphasis>The main notebook :</emphasis> The notebook design has been chosen in order to avoid annoying popup
	    dialogues. The order of the notebook pages is user configurable. The first page of the notebook
	    is the login screen. As most user settings are stored on the database backend, the gnumed client will
	    not be functional before the backend connection has happened.
	    </para>

        </sect2>
    	</sect1>
	
    	<sect1 id=drug-browser>
	<title>Pharmaceutical Reference Browser</title>

	    <sect2>
		<title>Short Description</title>

    		<para>
		Browser for Drug database.
		</para>

    	    </sect2>

	    <sect2>
		<title>Data Shown/Accessible</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Drug decscription as supplied by database.[text]</para></listitem>
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Functionality</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Browse drugs by generic name, brand name and inidication.</para></listitem>
		    <listitem><para>Hold tool icons and generally important information specific to the current module</para></listitem>
		</itemizedlist>
    	    </sect2>

    	    <sect2>
	    <title>Internals / Additional Information</title>
	    	    <orderedlist numeration="arabic">
	    <listitem><para>
	    Files: 
	    </para><screen>
	    gmDrugObject: 	query abstraction
	    gmDrugView:	drug abstraction (hides index search, product info creation and
			    so on)
	    gmDrugDisplay:	frontend to display drug information

	    ~/.gnumed/gnumed.conf (default config file)
	    &lt;SOMEDIR&gt;/&lt;DATABASE_QUERY_DEFINITION_FILE&gt;
	    </screen></listitem>

	    <listitem>
	    <para>Configuration</para>
	    <itemizedlist>

	    <listitem><para>
	    Pointers to the default drug database used in 
	    <filename>~/.gnumed/gnumed.conf</filename> (default config file):
	    <screen>
[DrugReferenceBrowser]                                                          
drugDBname = &lt;dbname&gt;

[&lt;dbname&gt;]
configfile = &lt;PathToDrugDBConfigFile&gt;
	    </screen>
	    </para>
	    <para>
	    where dbname references  the path entry and the &lt;PathToDrugDBConfigFile&gt;
	    points to a config file holding detailed information on queries, output formatting etc. 
	    (There are two separate entries to allow for more than one drug database.)
	    </para>
	    </listitem>

	   <listitem><para>
	   in DrugDBConfigFile:
	   </para>
	   <para>
	       There are two different types of entries : 
	       <orderedlist>

	       <listitem><para>
	       Query definitions (defining queries that can be accessed via the query group name
	       </para></listitem>
	       
	       <listitem><para>
	       format definitions (defining formatting of fetched data in the product info widget of the drug reference browser
	       </para></listitem>
	       </orderedlist>
	       
	       <para>
	       Query Definition:
	       </para>
	   <screen>
    
    [EntryGroupNameY]
    type=query 			# type=query identifies queries 
    querygroup=&lt;querygroupname&gt;	# identifies the query group the query belongs
				# to. All queries belonging to one group are 
                                # fetched at once by DrugObject.
    query=$query$
    &lt;here comes the query text, possibly containing %s to map variables&gt;
    $query$
    variables=&lt;variables returned in result dictionary as keys (column names)&gt;
    mappings=&lt;variables mapped to query string in order of appearance&gt;
	</screen>

	<para>
	Format Definition:
    	</para>
	<screen>
    [EntryGroupNameX]
    type=format			# identifies format information used by produc info
    querygroup=&lt;query group&gt;	# querygroup holding parameters needed by this
    				# part of product info
    formattype=&lt;ftype&gt;		# one of single, heading, noheading and list
    position=&lt;#num&gt;		# position of appearance in product info sheet	
    usedvars=&lt;vars used&gt;	# should match format string mappings
    heading=$heading$		# heading, needed if not ftype='noheadings'
	&lt;heading&gt;
    $heading$
    format=$format$
    &lt;e.g. %(presentation)s &gt;	# format string containing parameter names
    				# that should be mapped from result dict
                                # if all parameter in result are empty,
                                # this text part will be ignored
    $format$
	</screen>
	</itemizedlist>
	</listitem>

	<listitem><para>
	Guide to configure the Drug Reference Browser for a particular database
	</para>
	<procedure>
	<step><para>Create a &lt;DATABASE_QUERY_DEFINITION_FILE&gt; and configure your default gnumed config file accordingly (see above).</para></step>
    	<step><para>create query definitions for all query groups and parameters needed. </para>
	<para>
      	You will at least need the query groups 
	</para>
	<itemizedlist>
	<listitem><para>
      	'brand_index_exact' : a index of brand products selected from a list by a at least partial name
       (mapping : 'Key' - holding the name (or parts of it) to search for; 
       parameters expected as result : a list of brand products identified by at least parameters 'id' and 'name', additional parameters will be displayed, too)
	</para></listitem>
	<listitem><para>'generic_index_exact' : a index of generic substances, see  'brand_index_exact' for details
	</para></listitem>        
       <listitem><para> 'product_info' : a group holding all details on a specific drug (brand product) selected by a unique ID (var 'ID') from the list of all drugs. 
        This group should contain queries that select information from different
        tables using only the drug ID. The number of queries is not limited.
	</para></listitem>
	</itemizedlist>
	<para>
        The data fetched by these queries must be processed by a format definition to be displayed in the product info widget. There is no 1:1 mapping between query definitions and format definitions (that is, both types access a pool of parameters that are supplied by the queries and processed by format definition, but you don't have to use all parameters fetched. You must, however, query all parameters you would like to display. :)
	</para></step>
	<step><para>
    	Create format definitions for all sections you would like to display.
	</para><para>
    Every section consist of maximal two parts: a section heading and its content. Both types can be omitted (format type 'heading' takes only a heading and format type 'noheading' takes only content). Format type 'single' has a heading and expects a single result (i.e. no list). Format type 'list' had a heading and expects a variable containing a list.
	</para><para>    All format types except 'heading' expect a list of parameters used in entry 'usedvars' (the same that are used in the format string) to check for empty parameter sets (One could extract those variables from the format string too. Currently, however, this is not supported). Empty parameter sets will not be displayed. That can be used to display information that is not present with all drugs in the database without printing only headings with empty paragraphs.
	</para><para>    The parameters used will be mapped to the dictionary created by query group 'product_info'. 
	</para><para>    Every entry must contain an unique positional index (entry 'position', non-negative integer) that defines the order of appearance of format strings in product info sheet.
	</para></step>

	<step><para>
     	 Try it. If it fails, send me an email &lt;hilmar.berger@gmx.de&gt; or ask somebody else at the gnumed-devel list.
	</para></step>
	</procedure>
	</orderedlist>
            </sect2>
    	</sect1>

    	<sect1 id=prescription>
	<title>Prescription Dialog</title>

	    <sect2>
		<title>Short Description</title>

    		<para>
		Dialog used for writing a prescription. Shows additional information about prescribed drug.
		</para>

    	    </sect2>

	    <sect2>
		<title>Data Shown/Accessible</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Class of Drug []</para></listitem>
		    <listitem><para>Generic Name []</para></listitem>
		    <listitem><para>Brand Name []</para></listitem>
		    <listitem><para>Strength []</para></listitem>
		    <listitem><para>Direction []</para></listitem>
		    <listitem><para>Indication (what is the drug prescribed for) []</para></listitem>
		    <listitem><para>Repeats []</para></listitem>
		    <listitem><para>Quantity []</para></listitem>
		    <listitem><para>Regulatory information []</para></listitem>
		</itemizedlist>
    	    </sect2>

	    <sect2>
		<title>Functionality</title>
		<itemizedlist mark=opencircle>
		    <listitem><para>Link to drug database.</para></listitem>
		</itemizedlist>
    	    </sect2>

    	    <sect2>
	    <title>Internals / Additional Information</title>
	    <para></para>
    	    </sect2>	    
    	</sect1>

    	<sect1 id=appointment-book>
	    <title>Appointment book</title>    	
    	    <sect2>
		<title>Functionality</title>
    		<para>The appointment book is aimed for front-desk staff. &nbsp;It allows to
		make, edit and cancel appointments.
		The doctors can view the appointment list too (who is in the waiting room?)
		or give appointments without interfering with the receptionists. It can be
		used as a time tracking tool, too as it allows to keep track of when a patient
		</para>
		<itemizedlist mark=opencircle>
		  <listitem><para>has booked</para></listitem>
		  <listitem><para>for when he has been booked</para></listitem>
		  <listitem><para>when the patient arrived</para></listitem>
		  <listitem><para>when and how long the patient has been seen</para></listitem>
		</itemizedlist>
    		<para>
		It also can fill in as a interface towards the billing package.
    		</para>
	    </sect2>

    	    <sect2>  
    	    <title>The "schedule widget"</title>
  
		<para>
		Central unit of the appoinment book is the schedule widget - a spreadsheet
		like GUI control. Within the appointment book framework, any number of schedules
		can be displayed simultaneously (for example one for each doctor in a practice).
		Date selection controls in the framework sterr all schedule widgets simultaneously
		- taht allows to quickly page through the weeks to see which doctor could
		still fit a patient in.
		</para>
		<para>"Today" is marked yellow, weekend days pink, and days where a doctor is
		not available are marked in grey. Of course, all colours are configurable.</para>
		<para>Data entry is simple &amp; efficient: after selecting a vacant time slot
		, one starts typing a few characters of a surname; if there might be many
		patients with the same surname, one can enter a few characters of a given
		name too, separated by a space. If the appointment should be longer than
		standard, keying in a '+' for each pre-defined increment will do the trick.
		 On Enter, a small dialogue pops up and takes obver the cursor. It displays
		all matches from the patient data base (matching surname fraction and optionally
		given name fraction), the cursor is already positioned on the first entry.
		Enter confirms, cursor keys move the selection, Alt-n allows to enter a new
		patient. Thus, in the most common cse the appointment is made with 5-6 keystrokes
		: 2 first characters of the surname, 2 first characters of the given name,
		Enter.
		</para>
		<screenshot>
		<screeninfo>"Schedule for one doctor with patient selector open. Size 679x815"</screeninfo>
		<graphic fileref="snapshots/schedule-mono.png"> </graphic>
		</screenshot>
    	    	</sect2>  

		<sect2>
		    <title>Calendar navigation</title>
		    <para>A few convenience buttons allow navigation between weeks and months around
		    the current date with a single keystroke or mouse click. For more demanding
		    date entry, a calendar popup is provided. Alt+c pops it up, cursor keys select,
		    enter confirms. alternatively, the mouse can be used.
		    </para>
		    <screenshot>
		    <screeninfo>"Schedule for 2 doctors with calendar widget active Size 1020x824"</screeninfo>
		    <graphic fileref="snapshots/schedule.png"></graphic>
		    </screenshot>

		    <para>
		    This images displays two doctors simultaneously. Any number of doctors can
		    be displayed, provided the screen is large enough for satisfactory visualization.
		    Alternatively, each schedule widget has a combo box on top which allows to
		    select any doctor available.
		    </para>
    	    	</sect2>  

    	    	<sect2>
		    <title>Context sensitive popup menus</title>

		    <screenshot>
		    <screeninfo>"Popup menu for a booked patient. Size 402x359"</screeninfo>
		    <graphic fileref="snapshots/appointment-popup-menu.png"></graphic>
		    </screenshot>
    
    	    	    <para>
		    By right clicking a cell (or typing Alt-o) a popup menu will offer a few
		    choices what else we can do with the booked patient. This is expandable via
		    plugin architecture.
    	    	    </para>
    	    	</sect2>

    	    	<sect2>
    	    	    <title>TO DO:</title>
 
		    <itemizedlist mark=opencircle>
			<listitem><para>testing</para></listitem>
			<listitem><para>write proper documentation</para></listitem>
			<listitem><para>popup menu functions not implemented yet</para></listitem>
			<listitem><para>new patient dialog not implemented yet</para></listitem>
			<listitem><para>billing package needs to be written</para></listitem>
			<listitem><para>printing</para></listitem>
		    </itemizedlist>
    	    	</sect2>    	    	
    	</sect1>	


</book>
